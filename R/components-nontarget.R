#' @include main.R
#' @include components.R
#' @include components-set.R
#' @include feature_groups-set.R
NULL

#' Components class for homologous series.
#'
#' This class is derived from \code{\link{components}} and is used to store
#' results from unsupervised homolog detection with the \pkg{\link{nontarget}}
#' package.
#'
#' Objects from this class are generated by
#' \code{\link{generateComponentsNontarget}}
#'
#' @slot homol A \code{list} with \code{homol} objects for each replicate group
#'   as returned by \code{\link{homol.search}}
#'
#' @references \addCitations{nontarget}{1} \cr\cr \addCitations{enviPat}{1}
#'
#' @seealso \code{\link{components}} and \link{component-generation}
#'
#' @export
componentsNT <- setClass("componentsNT", slots = c(homol = "list"), contains = "components")

#' @describeIn componentsNT Plots an interactive network graph for linked
#'   homologous series (\emph{i.e.} series with (partial) overlap which could
#'   not be merged). The resulting graph can be browsed interactively and allows
#'   quick inspection of series which may be related. The graph is constructed
#'   with the \pkg{\link{igraph}} package and rendered with
#'   \pkg{\link{visNetwork}}.
#'
#' @param obj The \code{componentsRC} object to plot.
#' @param onlyLinked If \code{TRUE} then only series with links are plotted.
#'
#' @return \code{plotGraph} returns the result of \code{\link{visNetwork}}.
#'
#' @references \addCitations{igraph}{1} \cr \cr \addCitations{visNetwork}{1}
#' @aliases plotGraph
#' @export
setMethod("plotGraph", "componentsNT", function(obj, onlyLinked)
{
    checkmate::assertFlag(onlyLinked)
    
    cInfo <- copy(obj@componentInfo)
    cInfo[, id := .I]
    cInfo[, linksIDs := lapply(links, match, table = names(obj))]
    allLinks <- unique(unlist(cInfo$linksIDs))
    cInfo <- cInfo[lengths(links) > 0 | id %in% allLinks]
    
    if (nrow(cInfo) == 0)
    {
        if (onlyLinked)
            stop("No component links in your data and onlyLinked = TRUE, so nothing to show.")
        nodes <- data.table(id = character(), label = character(), group = numeric())
        edges <- data.table(from = character(), to = character())
    }
    else
    {
        edges <- rbindlist(mapply(cInfo$name, cInfo$linksIDs, FUN = function(n, l)
        {
            data.table::data.table(from = n, to = cInfo$name[match(unlist(l), cInfo$id)])
        }, SIMPLIFY = FALSE))
        
        graph <- igraph::simplify(igraph::graph_from_data_frame(edges, directed = FALSE))
        fc <- igraph::fastgreedy.community(graph)
        
        data <- visNetwork::toVisNetworkData(graph)
        nodes <- as.data.table(data$nodes)
        nodes[, group := fc$membership]
        edges <- data$edges
    }

    if (!onlyLinked)
    {
        unNodes <- data.table(id = setdiff(names(obj), cInfo$name), group = 0)
        unNodes[, label := id]
        nodes <- rbind(nodes, unNodes)
    }
    
    nodes[, shape := "circle"]

    infos <- obj@componentInfo[match(nodes$id, name), c("ret_increment", "mz_increment", "size"), with = FALSE]
    hsFGroups <- sapply(nodes$id, function(cmp) paste0(unique(obj[[cmp]]$group), collapse = ", "))
    hsRGroups <- sapply(nodes$id, function(cmp) paste0(unique(obj[[cmp]]$rGroup), collapse = ", "))
    nodes[, title := sprintf("<b>%s</b> (RT: %.2f; m/z: %.4f; #%d)<br>fGroups: <i>%s</i><br>rGroups: <i>%s</i>",
                             nodes$label, infos$ret_increment, infos$mz_increment, infos$size, hsFGroups, hsRGroups)]
    
    visNetwork::visNetwork(nodes = nodes, edges = edges)
})


#' @details \code{generateComponentsNontarget} uses
#'   \href{https://cran.r-project.org/web/packages/nontarget/index.html}{the
#'   nontarget R package} to generate components by unsupervised detection of
#'   homologous series. In the first step the \code{\link{homol.search}}
#'   function is used to detect all homologues within each replicate group
#'   (analyses within each replicate group are averaged prior to detection).
#'   Then, homologous series across replicate groups are merged in case of full
#'   overlap or when merging of partial overlapping series causes no conflicts.
#'
#' @param rtRange A numeric vector containing the minimum and maximum retention
#'   time (in seconds) between homologues. Series are always considered from low
#'   to high \emph{m/z}, thus, a negative minimum retention time allows
#'   detection of homologous series with increasing \emph{m/z} and decreasing
#'   retention times. These values set the \code{minrt} and \code{maxrt}
#'   arguments of \code{\link{homol.search}}.
#' @param mzRange A numeric vector specifying the minimum and maximum \emph{m/z}
#'   increment of a homologous series. Sets the \code{minmz} and \code{maxmz}
#'   arguments of \code{\link{homol.search}}.
#' @param elements A character vector with elements to be considered for
#'   detection of repeating units. Sets the \code{elements} argument of
#'   \code{\link{homol.search}} function.
#' @param absMzDevLink Maximum absolute \emph{m/z} deviation when linking
#'   series. This should usually be a bit higher than \code{absMzDev} to ensure
#'   proper linkage.
#' @param traceHack Currently \code{\link{homol.search}} does not work with \R
#'   \samp{>3.3.3}. This flag, which is enabled by default on these R versions,
#'   implements a (messy) workaround
#'   (\href{https://github.com/blosloos/nontarget/issues/6}{more details here}).
#'
#' @references \addCitations{nontarget}{1} \cr\cr \addCitations{enviPat}{1}
#'
#' @rdname component-generation
#' @export
setMethod("generateComponentsNontarget", "featureGroups", function(fGroups, ionization, rtRange = c(-120, 120), mzRange = c(5, 120),
                                                                   elements = c("C", "H", "O"), rtDev = 30, absMzDev = 0.002,
                                                                   absMzDevLink = absMzDev * 2, extraOpts = NULL,
                                                                   traceHack = all(R.Version()[c("major", "minor")] >= c(3, 4)))
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(fGroups, "featureGroups", add = ac)
    checkmate::assertChoice(ionization, c("positive", "negative"), add = ac)
    checkmate::assertNumeric(rtRange, finite = TRUE, any.missing = FALSE, len = 2, add = ac)
    checkmate::assertNumeric(mzRange, lower = 0, finite = TRUE, any.missing = FALSE, len = 2, add = ac)
    checkmate::assertCharacter(elements, min.chars = 1, any.missing = FALSE, min.len = 1, add = ac)
    aapply(checkmate::assertNumber, . ~ rtDev + absMzDev + absMzDevLink, lower = 0, finite = TRUE, fixed = list(add = ac))
    checkmate::assertList(extraOpts, any.missing = FALSE, names = "unique", null.ok = TRUE, add = ac)
    checkmate::assertFlag(traceHack, add = ac)
    checkmate::reportAssertions(ac)

    if (length(fGroups) == 0)
        return(componentsNT(homol = list(), componentInfo = data.table(), components = list(),
                            algorithm = "nontarget"))

    hash <- makeHash(fGroups, ionization, rtRange, mzRange, elements, rtDev, absMzDev, absMzDevLink, extraOpts)
    cd <- loadCacheData("componentsNontarget", hash)
    if (!is.null(cd))
        return(cd)

    gTable <- groupTable(fGroups)
    gInfo <- groupInfo(fGroups)
    anaInfo <- analysisInfo(fGroups)

    utils::data(isotopes, package = "enviPat")

    # adduct.search() and homol.search() call stop() when nothing is found (arg!) --> use tryCatch

    # For now just stick with homologues as there is no easy way to do adduct/isotopes over multiple analyses
    # find homologous series for each replicate group
    rGroups <- unique(anaInfo$group)
    groupTablesRG <- sapply(rGroups, function(rg)
    {
        fGrpRep <- replicateGroupFilter(fGroups, rg, verbose = FALSE)
        return(if (length(fGrpRep) == 0) NULL else as.data.table(fGrpRep, average = TRUE))
    }, simplify = FALSE)

    homArgs <- list(isotopes = isotopes, elements = elements, minmz = mzRange[1],
                     maxmz = mzRange[2], minrt = rtRange[1], maxrt = rtRange[2], ppm = FALSE,
                     mztol = absMzDev, rttol = rtDev)
    if (!is.null(extraOpts))
        homArgs <- modifyList(homArgs, extraOpts)

    
    homList <- sapply(rGroups, function(rg)
    {
        gt <- groupTablesRG[[rg]][, c("mz", rg, "ret"), with = FALSE] # convert to nontarget peaklist format
        
        if (is.null(gt))
            return(NULL) # rep group doesn't have feature groups
        
        if (traceHack)
            suppressMessages(trace(nontarget::homol.search, function() {})) # put in dummy trace
        
        # UNDONE: find some way to differentiate between actual errors?
        hom <- tryCatch(do.call(nontarget::homol.search, c(list(gt), homArgs)),
                        error = function(e) FALSE)
        
        if (traceHack)
            suppressMessages(untrace(nontarget::homol.search))
        
        if (is.logical(hom))
            return(NULL) # no results
        
        return(hom)
    }, simplify = FALSE)
    homList <- homList[!sapply(homList, is.null)]
    
    compTab <- rbindlist(mapply(homList, names(homList), SIMPLIFY = FALSE, FUN = function(hom, rg)
    {
        stopifnot(identical(hom[[3]][["HS IDs"]], hom[[3]][["HS cluster"]])) # what is the difference!?
        
        homTab <- as.data.table(hom[[3]])
        
        gNames <- groupTablesRG[[rg]]$group
        
        # peak IDs are now numeric indices of a subset of the original feature
        # groups. Replace them by group names to allow easy comparison.
        homTab[, groups := list(sapply(`peak IDs`, function(pids)
        {
            ginds <- as.integer(unlist(strsplit(pids, ",")))
            ginds <- ginds[order(gInfo[gNames[ginds], "mzs"])] # ensure they are from low to high m/z
            return(list(gNames[ginds]))
        }, simplify = FALSE))]
        
        homTab[, c("HS IDs", "peak IDs") := NULL]
        homTab[, (rg) := list(groups)]
        
        return(homTab)
    }), fill = TRUE)

    if (nrow(compTab) == 0)
        return(componentsNT(componentInfo = data.table(), components = list(), algorithm = "nontarget"))

    # check which series should be linked
    compTab[, links := list(list(integer()))]

    for (r in seq_len(nrow(compTab)))
    {
        series <- compTab[["groups"]][[r]][[1]]
        links <- integer(0)
        for (ro in seq_len(nrow(compTab)))
        {
            if (r == ro)
                next

            if (abs(compTab[["m/z increment"]][r] - compTab[["m/z increment"]][ro]) > absMzDev ||
                abs(compTab[["RT increment"]][r] - compTab[["RT increment"]][ro]) > rtDev)
                next # different series

            otherSeries <- compTab[["groups"]][[ro]][[1]]

            if (sum(series %in% otherSeries) < 1) # UNDONE: minimum overlap?
                next

            # check for conflicts: groups that are not present in both but with
            # m/z values close or equal to those groups that are present
            missingG <- setdiff(series, otherSeries)
            missingOtherG <- setdiff(otherSeries, series)

            mzSame <- function(mz1, mz2) numLTE(abs(mz1 - mz2), absMzDevLink)
            
            if (any(sapply(missingG, function(mg) any(mzSame(gInfo[mg, "mzs"], gInfo[otherSeries, "mzs"])))) ||
                any(sapply(missingOtherG, function(mg) any(mzSame(gInfo[mg, "mzs"], gInfo[series, "mzs"])))))
                next
            
            links <- c(links, ro)
        }

        set(compTab, r, "links", list(list(links)))
    }
    
    presentRGroups <- rGroups[sapply(rGroups, function(rg) !is.null(compTab[[rg]]))]

    # merge any pairs of series that are just pointing to each other: they are
    # either exactly the same or otherwise subsets of each other that can be
    # merged without conflicts

    compTab[, keep := TRUE]
    for (r in seq_len(nrow(compTab)))
    {
        if (compTab[["keep"]][r] == FALSE)
            next # already merged

        links <- compTab[["links"]][[r]]
        
        for (other in links)
        {
            otherLinks <- compTab[["links"]][[other]]
            # linkage is equal?
            if (length(links) == length(otherLinks) && all(otherLinks == r | otherLinks %in% links))
            {
                # merge groups
                mGroups <- union(compTab[["groups"]][[r]][[1]], compTab[["groups"]][[other]][[1]])
                mGroups <- mGroups[order(gInfo[mGroups, "mzs"])] # make sure order stays correct
                set(compTab, r, "groups", list(list(list(mGroups))))
                
                # mark presence
                lc <- compTab[other, presentRGroups, with = FALSE]
                for (rg in presentRGroups)
                {
                    if (!is.null(lc[[rg]][[1]]))
                        set(compTab, r, rg, list(list(lc[[rg]][[1]]))) # need to rewrap it in a list?
                }
                
                # update statistics
                indBoth <- c(r, other)
                set(compTab, r, "m/z increment", mean(compTab[["m/z increment"]][indBoth]))
                set(compTab, r, "RT increment", mean(compTab[["RT increment"]][indBoth]))
                set(compTab, r, "min. RT in series", min(compTab[["min. RT in series"]][indBoth]))
                set(compTab, r, "max. RT in series", max(compTab[["max. RT in series"]][indBoth]))
                set(compTab, r, "max.-min. RT", compTab[["max. RT in series"]][r] - compTab[["min. RT in series"]][r])
                
                set(compTab, other, "keep", FALSE) # remove other
                set(compTab, r, "links", list(list(setdiff(links, other)))) # unlink
            }
        }
    }

    # clearout merged series
    compTab[, IDs := seq_len(.N)] # store current row order
    compTab <- compTab[keep == TRUE]
    # update links
    for (r in seq_len(nrow(compTab)))
    {
        links <- compTab[["links"]][[r]]
        if (length(links) > 0)
        {
            # no sapply: this may return integer(0) for removed links and therefore make it a list
            # --> use lapply and convert from list afterwards
            newLinks <- lapply(links, function(l) compTab[IDs == l, which = TRUE])
            newLinks <- newLinks[lengths(newLinks) > 0] # length will be zero if linked series was removed
            newLinks <- unlist(newLinks)
            if (is.null(newLinks)) # no links anymore?
                newLinks <- integer()
            set(compTab, r, "links", list(list(newLinks)))
        }
    }
    compTab[, c("keep", "IDs") := NULL]

    # split all rows in list with tables containing groups per row
    comps <- lapply(seq_len(nrow(compTab)), function(cmpi)
    {
        allGroups <- compTab[["groups"]][[cmpi]][[1]]
        homSeries <- seq_along(allGroups)
        ret <- rbindlist(lapply(presentRGroups, function(rg)
        {
            grp <- compTab[[rg]][[cmpi]][[1]]
            if (!is.null(grp))
                return(data.table(rt = gInfo[grp, "rts"], mz = gInfo[grp, "mzs"], group = grp,
                                  hsnr = match(grp, allGroups), rGroup = rg,
                                  intensity = groupTablesRG[[rg]][group %in% grp, get(rg)]))
            return(NULL)
        }), fill = TRUE)
        setorderv(ret, c("hsnr"))
    })
    cNames <- paste0("CMP", seq_along(comps))
    names(comps) <- cNames

    cInfo <- copy(compTab)
    cInfo[, c("groups", "HS cluster") := NULL]
    setnames(cInfo,
             c("m/z increment", "RT increment", "min. RT in series", "max. RT in series", "max.-min. RT"),
             c("mz_increment", "ret_increment", "ret_min", "ret_max", "ret_range"))
    cInfo[, name := names(comps)]
    cInfo[, size := sapply(comps, nrow)]

    # convert from fgroup lists to logical presence
    for (rg in presentRGroups)
        set(cInfo, j = rg, value = !sapply(cInfo[[rg]], is.null))
    
    # Convert numeric links to component names. This also keeps links alive
    # after subsetting
    cInfo[, links := lapply(links, function(l) cNames[l])]

    ret <- componentsNT(homol = homList, componentInfo = cInfo, components = comps,
                        algorithm = "nontarget")
    saveCacheData("componentsNontarget", ret, hash)

    return(ret)
})

setMethod("generateComponentsNontarget", "featureGroupsSet", function(fGroups, ...)
{
    return(generateComponentsSet(fGroups, generateComponentsNontarget, ...,
                                 classGenerator = componentsNTSet))
})

