#' @include feature_groups.R
NULL

#' @rdname featureGroups-class
featureGroupsTable <- setClass("featureGroupsTable", contains = "featureGroups")

setMethod("initialize", "featureGroupsTable",
          function(.Object, ...) callNextMethod(.Object, algorithm = "table", ...))

#' Import feature groups from a table
#'
#' This function imports grouped features from a table, which can be either a \code{data frame} or a path to a file with
#' tabular data (\emph{e.g.} \file{.csv}).
#'
#' @templateVar algo a table
#' @templateVar generic importFeatureGroups
#' @templateVar algoParam table
#' @template algo_importer
#'
#' @details This function can be used to import feature group data from a table generated by the
#'   \code{\link[=as.data.table,featureGroups-method]{as.data.table}} (and \code{as.data.frame}) function, or the output
#'   from any other feature detection and grouping software. The column format mostly follows the format used by the
#'   \code{as.data.table} function with the \code{features} argument set to \code{TRUE}.
#'
#'   The function first imports the feature data from the table using \code{\link{importFeaturesTable}}. Please see its
#'   documentation for an overview of the columns that are expected in the input table.
#'
#'   In addition to the columns for feature data, the following columns are expected in the input table: \itemize{
#'
#'     \item \code{group}: a string naming the feature group in which the feature is part of. Values in this column
#'     should be unique per analysis. (\strong{mandatory})
#'
#'     \item \code{group_ret},\code{group_mz}: the retention time (in seconds) and m/z assigned to the feature group.
#'     Will be calculated from mean values of feature data if missing. (\strong{optional})
#'
#'   }
#'
#'   For data from an \link[=assignMobilities_feat]{IMS workflow}, the following additional columns are relevant: \itemize{
#'
#'     \item \code{group_mobility},\code{group_CCS}: the mobility and \acronym{CCS} assigned to the feature group. Will
#'     be calculated from mean values of feature data if missing. (\strong{optional})
#'
#'     \item \code{ims_parent_group}: a string naming the IMS parent group of the feature group (\code{NA} if none or
#'     not a mobility feature). (\strong{optional})
#'
#'   }
#'
#'   For data from a \link[=sets-workflow]{sets workflow}, the following additional columns are relevant: \itemize{
#'
#'     \item \code{group_ion_mz-<set>},\code{group_neutralMass},\code{group_adduct-<set>}: the ion m/z, neutral mass and
#'     adduct assigned to the feature group. Columns should be present for each set (\emph{e.g.}
#'     \code{ion_mz-positive}). Missing columns will be calculated from feature data. \strong{NOTE} If feature columns
#'     are missing, then the group columns will be used to create them.
#'
#'   }
#'
#' @param input The input to be imported: either a \code{data.frame}, \code{data.table} or file path to a file that can
#'   be imported with \code{\link{fread}}.
#' @param addCols Passed to \code{\link{importFeaturesTable}}.
#' @param groupAlgo,groupArgs \setsWF The grouping algorithm and a \code{list} with parameters that is used to re-group
#'   features when adduct assignments are changed, \emph{e.g.} by \code{\link{selectIons}}. Hence, these are often
#'   unused and dummy values can be set here, such as \code{groupAlgo="openms", groupArgs = list()}.
#'
#' @template analysisInfo-arg
#'
#' @note This function does not yet allow importing more advanced feature group properties, such as normalized
#'   intensities and predicted concentrations.
#'
#' @return An object derived from the class \code{\link{featureGroupsSet}} (if the imported data is from a
#'   \link[=sets-workflow]{sets workflow}) or \code{\link{featureGroups}} object otherwise.
#'
#' @seealso \code{\link{importFeaturesTable}} for importing features from a table.
#'   \code{\link[=as.data.table,featureGroups-method]{as.data.table}} for converting feature groups data to a
#'   \code{data.table} format. \code{\link{groupFeatures}} to generate feature groups.
#'
#' @export
importFeatureGroupsTable <- function(input, analysisInfo, addCols = NULL, groupAlgo, groupArgs = NULL)
{
    checkmate::assert(
        checkmate::checkDataFrame(input),
        checkmate::checkFileExists(input, access = "r"),
        .var.name = "input"
    )
    input <- if (is.character(input)) fread(input) else makeDT(input)
    analysisInfo <- assertAndPrepareAnaInfo(analysisInfo)
    
    gInfoNumCols <- c("ret", "mz", "mobility", "CCS")
    gInfoNumColsPrefix <- paste0("group_", gInfoNumCols)
    
    hasSets <- !is.null(input[["set"]])
    sufSets <- \(x) paste0(x, "-", setsNames)
    setsCol <- \(x, s) paste0(x, "-", s) 
    setsNames <- setsAnnAddCols <- setsAnnNumCols <- character()
    if (hasSets)
    {
        setsNames <- unique(input$set)
        setsAnnNumCols <- c(sufSets("group_ion_mz"), "group_neutralMass")
        setsAnnAddCols <- sufSets("group_adduct")
    }
    
    ac <- checkmate::makeAssertCollection()
    # NOTE: groupAlgo is checked below and only if sets data is being imported
    checkmate::assertList(groupArgs, null.ok = TRUE, add = ac)
    
    assertListVal(input, "group", checkmate::assertCharacter, any.missing = FALSE, min.chars = 1, add = ac)
    assertUniqueDTBy(input, c("group", "analysis"), add = ac)
    for (col in gInfoNumColsPrefix)
        assertListVal(input, col, checkmate::assertNumeric, any.missing = col %in% c("group_mobility", "group_CCS"),
                      finite = TRUE, add = ac, mustExist = FALSE)
    assertListVal(input, "ims_parent_group", checkmate::assertCharacter, any.missing = TRUE, min.chars = 1, add = ac,
                  mustExist = FALSE)
    
    if (hasSets)
    {
        for (col in setsAnnNumCols)
        {
            assertListVal(input, col, checkmate::assertNumeric, any.missing = col != "group_neutralMass", finite = TRUE,
                          add = ac, mustExist = FALSE)
        }
        for (col in setsAnnAddCols)
        {
            assertListVal(input, col, checkmate::assertCharacter, any.missing = TRUE, min.chars = 1, add = ac,
                          mustExist = FALSE)
        }
    }
    checkmate::reportAssertions(ac)
    
    setsAnn <- NULL
    if (hasSets)
    {
        # fill in annotations table: either from group columns (as exported by as.data.table()) or from feature columns
        # adduct: only reported as group_adduct-<set>
        # neutralMass: as mz column per feature, or group_neutralMass per group
        # ion_mz: per feature or group_ion_mz-<set>
        # --> make sure that both feature and feature group variations are present, this is needed for importing the
        # features and making the sets annotations table
        
        # adduct: not reported by ADT, feats to groups: take from unique by group table, group to feats: copy from corresponding set col
        # neutralMass: feats to groups: mean average by group; group to feats: not needed
        # ion_mz: feats to groups: mean average, group to feats: copy

        ensureCols <- function(featCol, setsCols)
        {
            if (!featCol %in% names(input) && !all(setsCols %in% names(input)))
                stop("Please specify at least one of the following columns: ",
                     paste0(c(featCol, setsCols), collapse = ", "), call. = FALSE)
        }
        
        # ensure either feature or fGroup column is present
        ensureCols("adduct", sufSets("group_adduct"))
        ensureCols("mz", "group_neutralMass")
        ensureCols("ion_mz", sufSets("group_ion_mz"))
        
        # add missing feature columns from group data (mz from neutralMass not needed: mz should always be there)
        if (is.null(input[["adduct"]]))
            input[, adduct := get(paste0("group_adduct-", set)), by = "set"]
        if (is.null(input[["ion_mz"]]))
            input[, ion_mz := get(paste0("group_ion_mz-", set)), by = "set"]
        
        for (s in setsNames)
        {
            cn <- setsCol("group_adduct", s)
            if (is.null(input[[cn]]))
                input[, (cn) := adduct]
            cn <- setsCol("group_ion_mz", s)
            if (is.null(input[[cn]]))
                input[, (cn) := mean(ion_mz), by = c("group", "set")]
        }
        if (is.null(input[["neutralMass"]]))
            input[, neutralMass := mean(mz), by = "group"]
    }
    
    inputFeat <- copy(input)
    # inputFeat <- removeDTColumnsIfPresent(inputFeat, c("group", gInfoColsPrefix, "group_mobility_collapsed",
    #                                                    "group_CCS_collapsed", setsAnnAddCols, setsAnnNumCols))
    importedFeat <- importFeaturesTable(inputFeat, analysisInfo, addCols = addCols)
    analysisInfo <- analysisInfo(importedFeat) # may be updated
    
    for (col in gInfoNumCols)
    {
        gcol <- paste0("group_", col)
        if (is.null(input[[gcol]]) && !is.null(input[[col]]))
            input[, (gcol) := mean(get(col)), by = "group"]
    }
    
    gInfo <- unique(input, by = "group")
    gInfo <- subsetDTColumnsIfPresent(gInfo, c("group", gInfoNumColsPrefix, "ims_parent_group"))
    setnames(gInfo, gInfoNumColsPrefix, gInfoNumCols, skip_absent = TRUE)
    setcolorder(gInfo, "CCS", after = last(names(gInfo)), skip_absent = TRUE) # put CCS at the end of the table
    
    if (hasMobilities(importedFeat) && is.null(gInfo[["ims_parent_group"]]))
        gInfo[, ims_parent_group := NA_character_]
    
    gTable <- data.table(matrix(0, nrow = nrow(analysisInfo), ncol = nrow(gInfo)))
    setnames(gTable, gInfo$group)
    ftindex <- data.table(matrix(0L, nrow = nrow(analysisInfo), ncol = nrow(gInfo)))
    setnames(ftindex, gInfo$group)
    for (grp in gInfo$group)
    {
        ftg <- input[group == grp, c("ID", "analysis", "intensity")]
        anai <- match(ftg$analysis, analysisInfo$analysis) # align analysis order
        
        set(gTable, anai, grp, ftg$intensity)
        
        finds <- sapply(seq_len(nrow(ftg)), \(i) importedFeat[[ftg$analysis[i]]][ID == ftg$ID[i], which = TRUE])
        set(ftindex, anai, grp, finds)
    }
    
    constArgs <- list(groups = gTable, groupInfo = gInfo, ftindex = ftindex, features = importedFeat)
    ret <- if (hasSets)
    {
        assertGroupFeatAlgo(groupAlgo)
        
        ann <- unique(input, by = c("set", "group"))[, c("set", "group", setsAnnAddCols, setsAnnNumCols), with = FALSE]
        for (s in setsNames)
        {
            cols <- c(setsCol("group_adduct", s), setsCol("group_ion_mz", s))
            ann[set == s, c("adduct", "ion_mz") := mget(cols)]
            ann[, (cols) := NULL]
        }
        setnames(ann, "group_neutralMass", "neutralMass")
        setcolorder(ann, c("set", "group", "adduct", "neutralMass", "ion_mz"))
        do.call(featureGroupsSet, c(constArgs, list(annotations = ann, algorithm = "table-set", groupAlgo = groupAlgo,
                                                    groupArgs = if (is.null(groupArgs)) list() else groupArgs)))
    }
    else
        do.call(featureGroupsTable, constArgs)
    
    printf("Imported %d feature groups.\n", nrow(gInfo))
    
    return(ret)
}
