# SPDX-FileCopyrightText: 2016 - 2025 Rick Helmus <r.helmus@uva.nl>
#
# SPDX-License-Identifier: GPL-3.0-only

#' @include main.R
#' @include features.R
NULL

#' @rdname features-class
featuresTable <- setClass("featuresTable", contains = "features")

setMethod("initialize", "featuresTable", function(.Object, ...) callNextMethod(.Object, algorithm = "table", ...))

#' Import features from a table
#'
#' This function imports features from a table, which can be either a \code{data frame} or a path to a file with tabular
#' data (\emph{e.g.} \file{.csv}).
#'
#' @templateVar algo a table
#' @templateVar generic importFeatures
#' @templateVar algoParam table
#' @template algo_importer
#'
#' @details This function can be used to import features from a table generated by the
#'   \code{\link[=as.data.table,features-method]{as.data.table}} (and \code{as.data.frame}) function, or the output from
#'   any other feature detection software. The column format mostly follows the format used by the \code{as.data.table}
#'   function.
#'
#'   The following columns must be present: \itemize{
#'
#'     \item \code{analysis}: the analysis name (corresponding the the \link[=analysis-information]{analysis information}).
#'
#'     \item \code{ret}: the retention time of the feature (in seconds).
#'
#'     \item \code{mz}: the m/z value of the feature.
#'
#'     \item \code{intensity}: the peak intensity of the feature.
#'
#'   }
#'
#'   The following columns are optional, but usually recommended: \itemize{
#'
#'     \item \code{ID}: the feature ID. Should be unique across the features from the same analysis. If not present, a
#'     sequential ID is automatically generated.
#'
#'     \item \code{area}: the peak area of the feature. If not present, it is calculated as \code{2.5*intensity}.
#'
#'     \item \code{retmin} and \code{retmax}: the minimum and maximum retention time range of the feature. If not present,
#'     they are derived by subtraction or addition of \code{ret} by \code{defaultLim("retention", "narrow")} (see
#'     \link{limits}).
#'
#'     \item \code{mzmin} and \code{mzmax}: the minimum and maximum m/z range of the feature. If not present, they are
#'     derived by subtraction or addition of \code{mz} by \code{defaultLim("mz", "narrow")} (see \link{limits}).
#'
#'   }
#'
#'   If a \code{mobility} column is present, it is assumed that the features are from an \link[=assignMobilities_feat]{IMS
#'   workflow}. In this case \itemize{
#'
#'     \item \code{mobility}: specifies the mobility of the feature.
#'
#'     \item \code{mobmin} and \code{mobmax}: the minimum and maximum mobility range of the feature. If not present,
#'     they are derived by subtraction or addition of \code{mobility} by \code{defaultLim("mobility", "narrow")} (see
#'     \link{limits}). (\strong{optional})
#'
#'     \item \code{mob_area} and \code{mob_intensity}: the peak area and intensity of the peak in the mobilogram for the
#'     feature. (\strong{optional})
#'
#'     \item \code{ims_parent_ID}: the ID of the IMS parent in a \link[=assignMobilities_feat]{post mobility assignment}
#'     workflow. (\strong{optional})
#'
#'     \item \code{mob_assign_method}: a string that names the method used to assign the mobility to the feature.
#'     (\strong{optional})
#'
#'   }
#'
#'   If a \code{set} column is present, it is assumed that the features are from a \link[=sets-workflow]{sets workflow}.
#'   In this case \itemize{
#'
#'     \item \code{set}: specifies the set name in which the feature is present.
#'
#'     \item \code{mz} and \code{ion_mz}: specify the \emph{neutral mass} and \emph{ionized m/z} of the feature,
#'     respectively.
#'
#'     \item \code{adduct}: specifies the \link{adduct} of the feature (generic textual format), \emph{e.g.}
#'     \code{"[M+H]+"}.
#'
#'   }
#'
#' @param input The input to be imported: either a \code{data.frame}, \code{data.table} or file path to a file that can
#'   be imported with \code{\link{fread}}.
#' @param addCols A \code{character} vector with additional columns that should be included in the imported features
#'   object. These columns are not used by \pkg{patRoon} and should not interfere with internally used columns (these
#'   will be ignored with a warning if they do).
#'
#' @template analysisInfo-arg
#'
#' @return An object derived from the class \code{\link{featuresSet}} (if the imported features are from a
#'   \link[=sets-workflow]{sets workflow}) or \code{\link{features}} object otherwise.
#'
#' @note The \code{"set"} column in the \link[=analysis-information]{analysis information} is not used when importing
#'   data (this column is present when obtaining the analysis information from a sets object with
#'   \code{\link{analysisInfo}}).
#'
#' @seealso \code{\link{importFeatureGroupsTable}} to import feature group data from a table. 
#'   \code{\link[=as.data.table,features-method]{as.data.table}} for converting features to a \code{data.table} format.
#'   \code{\link{findFeatures}} to generate feature data.
#'
#' @export
importFeaturesTable <- function(input, analysisInfo, addCols = NULL)
{
    checkmate::assert(
        checkmate::checkDataFrame(input),
        checkmate::checkFileExists(input, access = "r"),
        .var.name = "input"
    )
    analysisInfo <- assertAndPrepareAnaInfo(analysisInfo)
    checkmate::assertCharacter(addCols, any.missing = FALSE, min.chars = 1, null.ok = TRUE)
    
    input <- if (is.character(input)) fread(input) else makeDT(input)
    addCols <- if (is.null(addCols)) character(0) else addCols
    
    internalColsPresent <- intersect(c("group", "intensity_rel", "area_rel"), addCols)
    if (length(internalColsPresent) > 0)
    {
        warning("The following columns in 'addCols' are used internally and will not be considered: ",
                paste(internalColsPresent, collapse = ", "), call. = FALSE)
        addCols <- setdiff(addCols, internalColsPresent)
    }

    mobCols <- c("mobility", "mobmin", "mobmax", "mob_area", "mob_intensity", "ims_parent_ID", "mob_assign_method",
                 "mob_reintegr_method", "CCS")
    setsCols <- c("set", "adduct", "ion_mz")
    
    input <- subsetDTColumnsIfPresent(input, c("analysis", "ID", "ret", "retmin", "retmax", "mz", "mzmin", "mzmax",
                                               "intensity", "area", mobCols, setsCols, addCols))
    
    ac <- checkmate::makeAssertCollection()
    if (is.null(input[["ID"]]) && !is.null(input[["analysis"]]))
        input[, ID := seq_len(.N), by = "analysis"]
    else
    {
        checkmate::assert(
            checkmate::checkNumeric(input$ID, any.missing = FALSE),
            checkmate::checkCharacter(input$ID, any.missing = FALSE, min.chars = 1),
            .var.name = "input$ID", add = ac
        )
        assertUniqueDTBy(input, c("ID", "analysis"), add = ac)
    }
    for (col in c("ret", "mz", "intensity"))
        assertListVal(input, col, checkmate::assertNumeric, any.missing = FALSE, finite = TRUE, add = ac)
    
    maybeAddCol <- function(col, ..., am = FALSE)
    {
        if (is.null(input[[col]]))
            eval(substitute(input[, (col) := .v], list(.v = substitute(...))))
        else
            assertListVal(input, col, checkmate::assertNumeric, any.missing = am, finite = TRUE, add = ac)
        return(input)
    }
    
    maybeAddCol("area", 2.5 * intensity)
    maybeAddCol("retmin", ret - defaultLim("retention", "narrow"))
    maybeAddCol("retmax", ret + defaultLim("retention", "narrow"))
    maybeAddCol("mzmin", mz - defaultLim("mz", "narrow"))
    maybeAddCol("mzmax", mz + defaultLim("mz", "narrow"))
    
    hasMob <- !is.null(input[["mobility"]])
    if (hasMob)
    {
        assertListVal(input, "mobility", checkmate::assertNumeric, any.missing = TRUE, finite = TRUE, add = ac)
        maybeAddCol("mobmin", mobility - defaultLim("mobility", "narrow"), am = TRUE)
        maybeAddCol("mobmax", mobility + defaultLim("mobility", "narrow"), am = TRUE)
        maybeAddCol("mob_area", NA_real_, am = TRUE)
        maybeAddCol("mob_intensity", NA_real_, am = TRUE)
        if (is.null(input[["ims_parent_ID"]]))
            input[, ims_parent_ID := NA_character_]
        if (is.null(input[["mob_assign_method"]]))
            input[, mob_assign_method := NA_character_]
        if (is.null(input[["mob_reintegr_method"]]))
            input[, mob_reintegr_method := NA_character_]
    }
    else
    {
        mobColsPresent <- intersect(mobCols, names(input))
        if (length(mobColsPresent) > 0)
        {
            warning("The following columns are invalid in non-IMS workflows and will be removed: ",
                    paste(mobColsPresent, collapse = ", "), call. = FALSE)
            input[, (mobColsPresent) := NULL]
        }
    }
    
    hasSets <- all(setsCols %chin% names(input))
    if (hasSets)
    {
        assertListVal(input, "set", checkmate::assertCharacter, any.missing = FALSE, min.chars = 1, add = ac)
        assertListVal(input, "adduct", checkmate::assertCharacter, any.missing = FALSE, min.chars = 1, add = ac)
        assertListVal(input, "ion_mz", checkmate::assertNumeric, any.missing = FALSE, finite = TRUE, add = ac)
    }
    else
    {
        setsColsPresent <- intersect(setsCols, names(input))
        if (length(setsColsPresent) > 0)
        {
            warning(sprintf("In sets workflows the %s column(s) must be present, but only %s is found. ", setsCols,
                            setsColsPresent),
                    "Assuming this is not a sets workflow and removing interfering columns...", call. = FALSE)
            input[, (setsColsPresent) := NULL]
        }
    }
    
    checkmate::reportAssertions(ac)

    input[, ID := as.character(ID)]
    
    # sync common analyses between analysisInfo
    anasCommon <- intersect(analysisInfo$analysis, input$analysis)
    if (length(anasCommon) == 0)
        stop("No common analyses found between analysisInfo and input data.", call. = FALSE)
    
    anasAIOnly <- setdiff(analysisInfo$analysis, input$analysis)
    if (length(anasAIOnly) > 0)
        warning("The following analyses in analysisInfo are not present in the input data: ",
                paste(anasAIOnly, collapse = ", "), call. = FALSE)
    
    anasInputOnly <- setdiff(input$analysis, analysisInfo$analysis)
    if (length(anasInputOnly) > 0)
        warning("The following analyses in the input data are not present in analysisInfo: ",
                paste(anasInputOnly, collapse = ", "), call. = FALSE)
    
    analysisInfo <- analysisInfo[analysis %in% anasCommon]

    if (!is.null(analysisInfo[["set"]]))
        analysisInfo[, set := NULL]
    
    if (hasSets)
    {
        # move set assignments to anaInfo
        analysisInfo[, set := input$set[match(analysis, input$analysis)]]
        input[, set := NULL]
    }
    
    setcolorder(input, c("ID", "ret", "retmin", "retmax", "mz", "mzmin", "mzmax", "mobility", "mobmin", "mobmax",
                         "intensity", "area"), skip_absent = TRUE)

    fTable <- split(input, by = "analysis", keep.by = FALSE)
    fTable <- fTable[anasCommon] # subset and sync to anaInfo order
    
    constArgs <- list(analysisInfo = analysisInfo, features = fTable, hasMobilities = hasMob)
    ret <- if (hasSets)
        do.call(featuresSet, c(constArgs, list(algorithm = "table-set")))
    else
        do.call(featuresTable, constArgs)

    printf("Done importing features!\n")
    printf("IMS mode: %s\n", if (hasMob) "yes" else "no")
    printf("Sets mode: %s\n", if (hasSets) sprintf("yes (%s)", paste0(unique(analysisInfo$set), collapse = ", ")) else "no")
    printFeatStats(fTable)
    
    return(ret)
}
