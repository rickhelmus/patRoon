#' @include main.R
#' @include workflow-step.R
NULL

#' Formula lists class
#'
#' Contains data of generated chemical formulae for given feature groups.
#'
#' \code{formulas} objects are obtained from \link[=formula-generation]{formula
#' generators}.
#'
#' @slot formulas,featureFormulas Lists of all generated formulae. Use the
#'   \code{formulaTable} method for access.
#' @slot scoreRanges The original min/max values of all scorings when candidate
#'   results were generated. This is used for normalization.
#'
#' @param obj,x,object,formulas The \code{formulas} object.
#' @param \dots For \code{plotSpec}: Further arguments passed to
#'   \code{\link[graphics]{plot}}.
#'
#'   Others: Any further (and unique) \code{formulas} objects.
#' @param OM For \code{as.data.table}: if set to \code{TRUE} several columns
#'   with information relevant for organic matter (OM) characterization will be
#'   added (e.g. elemental ratios, classification). This will also make sure
#'   that \code{countElements} contains at least C, H, N, O, P and S.
#'
#'   For \code{filter}: If \code{TRUE} then several filters are applied to
#'   exclude unlikely formula candidates present in organic matter (OM). See
#'   Source section for details.
#' @param labels A \code{character} with names to use for labelling. If
#'   \code{NULL} labels are automatically generated.
#'
#' @templateVar seli analyses
#' @templateVar selOrderi analyses()
#' @templateVar selj feature groups
#' @templateVar selOrderj groupNames()
#' @templateVar optionalji TRUE
#' @templateVar dollarOpName feature group
#' @template sub_op-args
#'
#' @templateVar normParam normalizeScores
#' @templateVar excludeParam excludeNormScores
#' @template norm-args
#'
#' @section Source: Calculation of the aromaticity index (AI) and related double
#'   bond equivalents (DBE_AI) is performed as described in Koch 2015. Formula
#'   classification is performed by the rules described in Abdulla 2013.
#'   Filtering of OM related molecules is performed as described in Koch 2006
#'   and Kujawinski 2006. (see references).
#'
#' @references \insertRef{Koch2015}{patRoon} \cr\cr
#'   \insertRef{Abdulla2013}{patRoon} \cr\cr
#'   \insertRef{Koch2006}{patRoon} \cr\cr
#'   \insertRef{Kujawinski2006}{patRoon}
#'
#' @templateVar class formulas
#' @template class-hierarchy
#'
#' @export
formulas <- setClass("formulas", slots = c(formulas = "list", featureFormulas = "list", scoreRanges = "list"),
                     contains = "workflowStep")

setMethod("initialize", "formulas", function(.Object, ...)
{
    .Object <- callNextMethod(.Object, ...)

    # NOTE/UNDONE: change this whenever we want formula scoring normalization
    # based on _all_ results generated by the algorithm (ie like compounds)
    .Object@scoreRanges <- sapply(.Object@formulas, calculateFormScoreRanges, simplify = FALSE)

    .Object@formulas <- makeEmptyListNamed(.Object@formulas)
    .Object@featureFormulas <- makeEmptyListNamed(.Object@featureFormulas)
    
    return(.Object)
})

#' @describeIn formulas Accessor method to obtain generated formulae.
#'
#' @param features If \code{TRUE} returns formula data for features, otherwise
#'   for feature groups.
#'
#' @return \code{formulaTable} returns a \code{list} containing for each feature
#'   group (or feature if \code{features=TRUE}) a \code{\link{data.table}}
#'   with an overview of all generated formulae and other data such as candidate
#'   scoring and MS/MS fragments.
#'
#' @aliases formulaTable
#' @export
setMethod("formulaTable", "formulas", function(obj, features) if (features) obj@featureFormulas else obj@formulas)

#' @describeIn formulas Accessor method for the algorithm (a character
#'   string) used to generate formulae.
#' @export
setMethod("algorithm", "formulas", function(obj) obj@algorithm)

#' @templateVar class formulas
#' @templateVar what analyses
#' @template strmethod
#' @export
setMethod("analyses", "formulas", function(obj) names(obj@featureFormulas))

#' @templateVar class formulas
#' @templateVar what feature groups
#' @template strmethod
#' @export
setMethod("groupNames", "formulas", function(obj) names(obj@formulas))

#' @describeIn formulas Obtain total number of formulae entries.
#' @export
setMethod("length", "formulas", function(x) countUniqueFormulas(x@formulas))

#' @describeIn formulas Show summary information for this object.
#' @export
setMethod("show", "formulas", function(object)
{
    callNextMethod()

    ft <- formulaTable(object, TRUE)
    hasFeatForms <- length(ft) > 0
    ftcounts <- if (hasFeatForms) recursiveApplyDT(ft, function(x) length(unique(x$formula)), sapply) else 0
    ma <- mean(sapply(ftcounts, sum))
    mft <- mean(sapply(ftcounts, mean))
    printf("Formulas assigned to features:\n")
    printf("  - Total formula count: %d\n", sum(unlist(ftcounts)))
    printf("  - Average formulas per analysis: %.1f\n", ma)
    printf("  - Average formulas per feature: %.1f\n", mft)

    gft <- formulaTable(object)
    mfg <- if (length(gft) > 0) sapply(gft, function(ft) length(unique(ft$formula))) else 0
    printf("Formulas assigned to feature groups:\n")
    printf("  - Total formula count: %d\n", sum(mfg))
    printf("  - Average formulas per feature group: %.1f\n", mean(mfg))
})

#' @describeIn formulas Subset on feature groups.
#' @export
setMethod("[", c("formulas", "ANY", "missing", "missing"), function(x, i, j, ...)
{
    if (!missing(i))
    {
        i <- assertSubsetArgAndToChr(i, groupNames(x))
        x@featureFormulas <- sapply(x@featureFormulas, function(a) pruneList(a[i]),
                                    simplify = FALSE)
        x@featureFormulas <- pruneList(x@featureFormulas, TRUE)

        x@formulas <- x@formulas[i]
        x@scoreRanges <- x@scoreRanges[i]
    }

    return(x)
})

#' @describeIn formulas Extract a formula table. If both arguments (\code{i} and
#'   \code{j}) are specified, the feature specific formula table belonging to
#'   the analysis (\code{i})/feature group (\code{j}) is returned. Otherwise the
#'   formula table for the feature group specified by \code{j} is returned.
#' @export
setMethod("[[", c("formulas", "ANY", "ANY"), function(x, i, j)
{
    assertExtractArg(i)
    if (!missing(j))
        assertExtractArg(j)

    if (!missing(j))
    {
        # both arguments specified, return feature formula table

        if (length(x@featureFormulas) == 0)
            stop("This object does not contain formulas for features.")

        if (!is.character(i))
            i <- analyses(x)[i]

        if (!is.character(j))
            j <- groupNames(x)[j]

        return(x@featureFormulas[[c(i, j)]])
    }

    # else return regular feature group formulas

    if (!is.character(i))
        i <- groupNames(x)[i]
    return(x@formulas[[i]])
})

#' @describeIn formulas Extract a formula table for a feature group.
#' @export
setMethod("$", "formulas", function(x, name)
{
    eval(substitute(x@formulas[[NAME_ARG]], list(NAME_ARG = name)))
})

#' @describeIn formulas Generates a table with all candidate formulae for each
#'   feature group and other information such as element counts.
#'
#' @param average If set to \code{TRUE} an 'average formula' is generated for
#'   each feature group by combining all elements from all candidates and
#'   averaging their amounts. This obviously leads to non-existing formulae,
#'   however, this data may be useful to deal with multiple candidate formulae
#'   per feature group when performing elemental characterization.
#' @param countElements,countFragElements A \code{character} vector with
#'   elements that should be counted for each MS(/MS) formula candidate. For
#'   instance, \code{c("C", "H")} adds columns for both carbon and hydrogen
#'   amounts of each formula. Note that the neutral formula
#'   (\code{neutral_formula} column) is used to count elements of non-fragmented
#'   formulae, whereas the charged formula of fragments (\code{frag_formula}
#'   column) is used for fragments. Set to \code{NULL} to not count any
#'   elements.
#' @param maxFormulas,maxFragFormulas Maximum amount of unique candidate
#'   formulae (or fragment formulae) per feature group. Set to \code{NULL} to
#'   ignore.
#'
#' @template as_data_table-args
#'
#' @return \code{as.data.table} returns a \code{\link{data.table}}.
#'
#' @export
setMethod("as.data.table", "formulas", function(x, fGroups = NULL, average = FALSE, countElements = NULL,
                                                countFragElements = NULL, OM = FALSE,
                                                maxFormulas = NULL, maxFragFormulas = NULL,
                                                normalizeScores = "none", excludeNormScores = NULL)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(fGroups, "featureGroups", null.ok = TRUE, add = ac)
    checkmate::assertFlag(average, add = ac)
    checkmate::assertCharacter(countElements, min.chars = 1, any.missing = FALSE, null.ok = TRUE, add = ac)
    checkmate::assertCharacter(countFragElements, min.chars = 1, any.missing = FALSE, null.ok = TRUE, add = ac)
    checkmate::assertFlag(OM, add = ac)
    assertNormalizationMethod(normalizeScores, add = ac)
    checkmate::assertCharacter(excludeNormScores, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::reportAssertions(ac)

    fTable <- formulaTable(x)
    if (normalizeScores != "none")
    {
        fTable <- mapply(fTable, x@scoreRanges, SIMPLIFY = FALSE, FUN = normalizeFormScores,
                         MoreArgs = list(normalizeScores == "minmax", excludeNormScores))
    }

    ret <- rbindlist(fTable, fill = TRUE, idcol = "group")
    if (length(ret) == 0)
        return(ret)

    if (!is.null(fGroups))
    {
        ret[, c("ret", "mz") := groupInfo(fGroups)[group, ]]
        setcolorder(ret, c("group", "ret", "mz"))
    }

    if (average)
    {
        # collapse byMSMS: will be TRUE if at least an MS/MS formula candidate was there
        ret[, byMSMS := any(byMSMS), by = "group"]

        ret[, formula_avg_count := length(unique(formula)), by = "group"]

        avgCols <- c("formula", "neutral_formula")
        ret[, (avgCols) := lapply(.SD, function(f) averageFormulas(unique(f))), .SDcols = avgCols, by = "group"]

        # remove columns which don't really make sense anymore
        rmCols <- c("neutral_loss", "error", "formula_mz", "dbe", "anaCoverage",
                    "adduct", "rank", "explainedPeaks", "explainedIntensity",
                    # add any fragment columns
                    grep("^frag_", names(ret), value = TRUE),
                    formulaScorings()$name)

        rmCols <- getAllFormulasCols(rmCols, names(ret))
        if (length(rmCols) > 0)
            ret[, (rmCols) := NULL]

        ret <- unique(ret, by = c("group", "formula"))
    }
    else
    {
        if (!is.null(maxFormulas))
        {
            ret[, unFormNr := match(formula, unique(.SD$formula)), by = "group"]
            ret <- ret[unFormNr <= maxFormulas][, unFormNr := NULL]
        }

        if (!is.null(maxFragFormulas) && any(ret$byMSMS))
        {
            ret[, unFormNr := match(frag_formula, unique(.SD$frag_formula)),
                by = c("group", "byMSMS", "formula")]
            ret <- ret[unFormNr <= maxFragFormulas][, unFormNr := NULL]
        }
    }

    ret <- addElementInfoToFormTable(ret, countElements, countFragElements, OM)

    return(ret[])
})

#' @describeIn formulas Performs rule based filtering on formula results.
#'
#' @param minExplainedPeaks Minimum number of fragment peaks that are
#'   explained. Setting this to \samp{1} will remove any MS only formula
#'   results. Set to \code{NULL} to ignore.
#' @param topMost Retain no more than this amount of best ranked (or worst
#'   ranked if \code{negate=TRUE}) candidates for each feature group.
#' @param scoreLimits Filter results by their scores. Should be a named
#'   \code{list} that contains two-sized numeric vectors with the
#'   minimum/maximum value of a score (use \code{-Inf}/\code{Inf} for no
#'   limits). The names of each element should follow the values returned by
#'   \code{\link{formulaScorings}()$name}. For instance,
#'   \code{scoreLimits=list(isoScore=c(0.5, Inf))} specifies that the isotopic
#'   match score should be at least \samp{0.5}. More details of scorings can be
#'   obtained with \code{\link{formulaScorings}}. Note that a result without a
#'   specified scoring is never removed. Set to \code{NULL} to skip this filter.
#' @param negate If \code{TRUE} then filters are applied in opposite manner.
#' @template element-args
#'
#' @note \code{filter} does not modify any formula results for features (if
#'   present).
#'
#' @return \code{filter} returns a filtered \code{\link{formulas}} object.
#'
#' @export
setMethod("filter", "formulas", function(obj, minExplainedPeaks = NULL, elements = NULL,
                                         fragElements = NULL, lossElements = NULL,
                                         topMost = NULL, scoreLimits = NULL,
                                         OM = FALSE, negate = FALSE)
{
    scCols <- formulaScorings()$name

    ac <- checkmate::makeAssertCollection()
    aapply(checkmate::assertCount, . ~ topMost + minExplainedPeaks,
           positive = c(TRUE, FALSE), null.ok = TRUE, fixed = list(add = ac))
    aapply(checkmate::assertCharacter, . ~ elements + fragElements + lossElements,
           min.chars = 1, min.len = 1, null.ok = TRUE, fixed = list(add = ac))
    checkmate::assertList(scoreLimits, null.ok = TRUE, types = "numeric", add = ac)

    if (!is.null(scoreLimits))
    {
        checkmate::assertNames(names(scoreLimits), type = "unique", subset.of = scCols, add = ac)
        checkmate::qassertr(scoreLimits, "N2")
    }
    aapply(checkmate::assertFlag, . ~ OM + negate, fixed = list(add = ac))
    checkmate::reportAssertions(ac)

    cat("Filtering formulas... ")

    oldn <- length(obj)
    obj@formulas <- pruneList(sapply(groupNames(obj), function(grp)
    {
        formTable <- obj[[grp]]
        if (!is.null(minExplainedPeaks) && minExplainedPeaks > 0)
        {
            ft <- formTable[byMSMS == TRUE]
            if (nrow(ft) == 0)
                return(if (negate) formTable else ft)
            formTable <- ft
            fragCounts <- formTable[, ifelse(byMSMS, length(frag_formula), 0L), by = "formula"][[2]]
            if (negate)
                formTable <- formTable[fragCounts < minExplainedPeaks]
            else
                formTable <- formTable[fragCounts >= minExplainedPeaks]
        }

        if (!is.null(elements))
        {
            keep <- sapply(formTable$neutral_formula, checkFormula, elements, negate = negate)
            formTable <- formTable[keep]
        }
        if ((!is.null(fragElements) || !is.null(lossElements)))
        {
            ft <- formTable[byMSMS == TRUE]
            if (nrow(ft) == 0)
                return(if (negate) formTable else ft)
            formTable <- ft
            if (!is.null(fragElements))
            {
                keep <- formTable[, rep(any(sapply(frag_formula, checkFormula, fragElements, negate = negate)), .N),
                                  by = "formula"][[2]]
                formTable <- formTable[keep]
            }

            if (!is.null(lossElements))
            {
                keep <- formTable[, rep(any(sapply(neutral_loss, checkFormula, lossElements, negate = negate)), .N),
                                  by = "formula"][[2]]
                formTable <- formTable[keep]
            }
        }

        if (!is.null(scoreLimits))
        {
            for (sc in names(scoreLimits))
            {
                cols <- getAllFormulasCols(sc, names(formTable))
                if (length(cols) == 0)
                    next
                keep <- formTable[, do.call(pmin, c(.SD, list(na.rm = TRUE))) >= scoreLimits[[sc]][1] &
                                      do.call(pmax, c(.SD, list(na.rm = TRUE))) <= scoreLimits[[sc]][2],
                                  .SDcols = cols]
                formTable <- formTable[if (negate) !keep else keep]
            }
        }

        if (OM)
        {
            fElTable <- addElementInfoToFormTable(copy(formTable), NULL, NULL, OM = TRUE)
            keep <- fElTable[,
                         # rules from Kujawinski & Behn, 2006 (10.1021/ac0600306)
                         H >= 1/3 * C &
                         H <= ((2 * C) + N + 2) &
                         (H + N) %% 2 == 0 &
                         N <= C &
                         O <= C &
                         P <= 2 &
                         S <= 2 &

                         # rules from Koch & dittmar 2006 (10.1002/rcm.2386)
                         sapply(DBE_AI, checkmate::checkInt) &
                         HC <= 2.2 &
                         OC <= 1.2 &
                         NC <= 0.5]
            formTable <- formTable[if (negate) !keep else keep]
        }

        if (!is.null(topMost))
        {
            unForms <- unique(formTable$formula)
            unFormNrs <- formTable[, match(formula, unForms)]
            if (negate)
                unFormNrs <- length(unForms) - (unFormNrs - 1)
            formTable <- formTable[unFormNrs <= topMost]
        }

        return(formTable)
    }, simplify = FALSE), checkZeroRows = TRUE)

    obj@scoreRanges <- obj@scoreRanges[names(obj@formulas)]
    
    newn <- length(obj)
    printf("Done! Filtered %d (%.2f%%) formulas. Remaining: %d\n", oldn - newn, if (oldn == 0) 0 else (1-(newn/oldn))*100, newn)
    return(obj)
})

#' @describeIn formulas Returns an MS/MS peak list annotated with data from a
#'   given candidate formula.
#'
#' @param onlyAnnotated Set to \code{TRUE} to filter out any peaks that could
#'   not be annotated.
#'
#' @export
setMethod("annotatedPeakList", "formulas", function(obj, precursor, groupName, analysis = NULL, MSPeakLists,
                                                    onlyAnnotated = FALSE)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertString(precursor, min.chars = 1, add = ac)
    assertChoiceSilent(groupName, groupNames(obj), add = ac)
    checkmate::assertString(analysis, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::assertClass(MSPeakLists, "MSPeakLists", add = ac)
    checkmate::assertFlag(onlyAnnotated, add = ac)
    checkmate::reportAssertions(ac)

    if (!is.null(analysis))
    {
        formTable <- obj[[analysis, groupName]]
        spec <- MSPeakLists[[analysis, groupName]][["MSMS"]]
    }
    else
    {
        formTable <- obj[[groupName]]
        spec <- MSPeakLists[[groupName]][["MSMS"]]
    }

    if (is.null(spec))
        return(NULL)

    formTable <- formTable[byMSMS == TRUE & formula == precursor]
    if (nrow(formTable) > 0)
    {
        formTable <- formTable[formula == precursor]
        if (nrow(formTable) > 0)
        {
            fragInfo <- getFragmentInfoFromForms(spec, formTable)
            spec <- copy(spec)
            spec[, PLIndex := seq_len(nrow(spec))] # for merging
            spec <- merge(spec, fragInfo[, -c("intensity", "mz")], all.x = TRUE, by = "PLIndex")
            spec <- spec[, PLIndex := NULL]
        }
    }

    if (onlyAnnotated)
    {
        if (is.null(spec[["formula"]]))
            spec <- spec[0]
        else
            spec <- spec[!is.na(formula)]
    }

    return(spec[])
})

#' @describeIn formulas Plots a barplot with scoring of a candidate compound.
#'
#' @export
setMethod("plotScores", "formulas", function(obj, precursor, groupName, analysis = NULL,
                                             normalizeScores = "max",
                                             excludeNormScores = NULL, useGGPlot2 = FALSE)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertString(precursor, min.chars = 1, add = ac)
    checkmate::assertString(groupName, min.chars = 1, add = ac)
    checkmate::assertString(analysis, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::assertChoice(normalizeScores, c("none", "max", "minmax"))
    checkmate::assertCharacter(excludeNormScores, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::assertFlag(useGGPlot2, add = ac)
    checkmate::reportAssertions(ac)

    if (!is.null(analysis))
        formTable <- obj[[analysis, groupName]]
    else
        formTable <- obj[[groupName]]

    if (is.null(formTable) || nrow(formTable) == 0 || !precursor %in% formTable$formula)
        return(NULL)

    mcn <- character()
    if (!is.null(formTable[["mergedBy"]]))
        mcn <- unique(unlist(strsplit(formTable$mergedBy, ",", fixed = TRUE)))

    if (normalizeScores != "none")
        formTable <- normalizeFormScores(formTable, obj@scoreRanges[[groupName]],
                                         normalizeScores == "minmax", excludeNormScores)

    scoreCols <- getAllFormulasCols(formulaScorings()$name, names(formTable))
    scoreTable <- getPrecursorFormScores(formTable[formula == precursor], scoreCols)[, scoreCols, with = FALSE]
    makeScoresPlot(scoreTable, mcn, useGGPlot2)
})

setMethod("plotScoresHash", "formulas", function(obj, precursor, groupName, analysis = NULL,
                                                 normalizeScores = "max",
                                                 excludeNormScores = NULL, useGGPlot2 = FALSE)
{
    if (!is.null(analysis))
        formTable <- obj[[analysis, groupName]]
    else
        formTable <- obj[[groupName]]
    if (is.null(formTable) || nrow(formTable) == 0 || !precursor %in% formTable$formula)
        formTable <- NULL
    else if (normalizeScores == "none")
        formTable <- formTable[formula == precursor]

    return(makeHash(precursor, formTable, normalizeScores, excludeNormScores, useGGPlot2))
})

#' @describeIn formulas Plots an annotated spectrum for a given candidate
#'   formula of a feature or feature group.
#'
#' @param precursor The formula of the precursor (in ionic form, \emph{i.e.} as
#'   detected by the MS).
#' @param analysis A \code{character} specifying the analysis for which the
#'   annotated spectrum should be plotted. If \code{NULL} then annotation
#'   results for the complete feature group will be plotted.
#' @param title The title of the plot. Set to \code{NULL} for an automatically
#'   generated title.
#'
#' @template plotSpec-args
#'
#' @template useGGplot2
#'
#' @template plot-lim
#'
#' @template fsubscript_source
#'
#' @return \code{plotSpec} will return a \code{\link[=ggplot2]{ggplot object}}
#'   if \code{useGGPlot2} is \code{TRUE}.
#'
#' @export
setMethod("plotSpec", "formulas", function(obj, precursor, groupName, analysis = NULL, MSPeakLists,
                                           title = NULL, useGGPlot2 = FALSE, xlim = NULL, ylim = NULL, ...)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertString(precursor, min.chars = 1, add = ac)
    checkmate::assertString(groupName, min.chars = 1, add = ac)
    checkmate::assertString(analysis, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::assertClass(MSPeakLists, "MSPeakLists", add = ac)
    checkmate::assertString(title, null.ok = TRUE, add = ac)
    checkmate::assertFlag(useGGPlot2, add = ac)
    assertXYLim(xlim, ylim, add = ac)
    checkmate::reportAssertions(ac)

    if (is.null(title))
        title <- subscriptFormula(precursor)

    spec <- annotatedPeakList(obj, precursor, groupName, analysis, MSPeakLists)
    if (is.null(spec))
        return(NULL)

    if (useGGPlot2)
        return(makeMSPlotGG(spec) + ggtitle(title))

    makeMSPlot(spec, xlim, ylim, ..., main = title)
})

setMethod("plotSpecHash", "formulas", function(obj, precursor, groupName, analysis = NULL, MSPeakLists,
                                               title = NULL, useGGPlot2 = FALSE, xlim = NULL, ylim = NULL, ...)
{
    return(makeHash(precursor, annotatedPeakList(obj, precursor, groupName, analysis, MSPeakLists),
                    title, useGGPlot2, xlim, ylim, ...))
})

#' @describeIn formulas plots a Venn diagram (using \pkg{\link{VennDiagram}})
#'   outlining unique and shared formula candidates of up to five different
#'   \code{formulas} objects.
#'
#' @param vennArgs A \code{list} with further arguments passed to
#'   \pkg{VennDiagram} plotting functions. Set to \code{NULL} to ignore.
#'
#' @template plotvenn-ret
#'
#' @export
setMethod("plotVenn", "formulas", function(obj, ..., labels = NULL, vennArgs = NULL)
{
    allForms <- c(list(obj), list(...))

    ac <- checkmate::makeAssertCollection()
    checkmate::assertList(allForms, types = "formulas", min.len = 2, any.missing = FALSE,
                          unique = TRUE, .var.name = "...", add = ac)
    checkmate::assertCharacter(labels, min.chars = 1, len = length(allForms), null.ok = TRUE, add = ac)
    checkmate::assertList(vennArgs, names = "unique", null.ok = TRUE, add = ac)
    checkmate::reportAssertions(ac)

    if (is.null(labels))
        labels <- make.unique(sapply(allForms, algorithm))
    if (is.null(vennArgs))
        vennArgs <- list()

    allFormTabs <- lapply(allForms, as.data.table)
    do.call(makeVennPlot, c(list(allFormTabs, labels, lengths(allForms), function(obj1, obj2)
    {
        if (length(obj1) == 0 || length(obj2) == 0)
            return(data.table())
        fintersect(obj1[, c("group", "formula")], obj2[, c("group", "formula")])
    }, nrow), vennArgs))
})

#' @describeIn formulas plots an UpSet diagram (using the
#'   \code{\link[UpSetR]{upset}} function) outlining unique and shared formula
#'   candidates between different \code{formula} objects.
#'
#' @param nsets,nintersects See \code{\link[UpSetR]{upset}}.
#' @param upsetArgs A list with any further arguments to be passed to
#'   \code{\link[UpSetR]{upset}}. Set to \code{NULL} to ignore.
#'
#' @references \insertRef{Conway2017}{patRoon} \cr\cr
#'   \insertRef{Lex2014}{patRoon}
#'
#' @export
setMethod("plotUpSet", "formulas", function(obj, ..., labels = NULL, nsets = length(list(...)) + 1,
                                            nintersects = NA, upsetArgs = NULL)
{
    allForms <- c(list(obj), list(...))

    ac <- checkmate::makeAssertCollection()
    checkmate::assertList(allForms, types = "formulas", min.len = 2, any.missing = FALSE,
                          unique = TRUE, .var.name = "...", add = ac)
    checkmate::assertCharacter(labels, min.chars = 1, len = length(allForms), null.ok = TRUE, add = ac)
    checkmate::assertList(upsetArgs, names = "unique", null.ok = TRUE, add = ac)
    checkmate::assertCount(nsets, positive = TRUE)
    checkmate::assertCount(nintersects, positive = TRUE, na.ok = TRUE)
    checkmate::reportAssertions(ac)

    if (is.null(labels))
        labels <- make.unique(sapply(allForms, algorithm))

    allFormTabs <- mapply(allForms, labels, SIMPLIFY = FALSE, FUN = function(f, l)
    {
        ret <- as.data.table(f)
        if (length(ret) == 0)
            ret <- data.table(group = character(), formula = character())
        ret <- unique(ret[, c("group", "formula")])[, (l) := 1]
    })

    formTab <- Reduce(function(f1, f2)
    {
        merge(f1, f2, by = c("group", "formula"), all = TRUE)
    }, allFormTabs)

    formTab <- formTab[, labels, with = FALSE]
    for (j in seq_along(formTab))
        set(formTab, which(is.na(formTab[[j]])), j, 0)

    if (sum(sapply(formTab, function(x) any(x>0))) < 2)
        stop("Need at least two non-empty objects to plot")

    do.call(UpSetR::upset, c(list(formTab, nsets = nsets, nintersects = nintersects), upsetArgs))
})

#' @templateVar what formulas
#' @template consensus-form_comp
#'
#' @templateVar what formulas
#' @template consensus-common-args
#'
#' @return \code{consensus} returns a \code{formulas} object that is produced by
#'   merging results from multiple \code{formulas} objects.
#'
#' @export
setMethod("consensus", "formulas", function(obj, ..., absMinAbundance = NULL,
                                            relMinAbundance = NULL,
                                            uniqueFrom = NULL, uniqueOuter = FALSE,
                                            rankWeights = 1, labels = NULL)
{
    allFormulas <- c(list(obj), list(...))

    ac <- checkmate::makeAssertCollection()
    checkmate::assertList(allFormulas, types = "formulas", min.len = 2, any.missing = FALSE,
                          unique = TRUE, .var.name = "...", add = ac)
    checkmate::assertNumber(rankWeights, lower = 0, finite = TRUE, add = ac)
    checkmate::assertCharacter(labels, min.chars = 1, len = length(allFormulas), null.ok = TRUE, add = ac)
    checkmate::reportAssertions(ac)

    allFormNames <- if (!is.null(labels)) labels else make.unique(sapply(allFormulas, algorithm))
    assertConsCommonArgs(absMinAbundance, relMinAbundance, uniqueFrom, uniqueOuter, allFormNames)

    relMinAbundance <- max(NULLToZero(absMinAbundance) / length(allFormulas), NULLToZero(relMinAbundance))

    rankWeights <- rep(rankWeights, length.out = length(allFormulas))

    allFormulasLists <- sapply(seq_along(allFormulas), function(fi)
    {
        return(lapply(formulaTable(allFormulas[[fi]]), function(ft)
        {
            ret <- copy(ft)
            ret[, mergedBy := allFormNames[fi]]
            ranks <- seq_len(length(unique(ret$formula)))
            ret[, rank := ranks[.GRP], by = "formula"]
            ret[, rankscore := (.N - (rank - 1)) / .N * rankWeights[fi]]
            setnames(ret, paste0(names(ret), "-", allFormNames[fi]))
            return(ret)
        }))

    }, simplify = FALSE)

    # UNDONE: remove old style columns?
    uniqueCols <- c("neutral_formula", "formula_mz", "error", "dbe", "frag_mz", "frag_neutral_formula",
                    "frag_formula_mz", "frag_error", "neutral_loss", "frag_dbe", "min_intensity", "max_intensity",
                    "ana_min_intensity", "ana_max_intensity")

    consFormulaList <- allFormulasLists[[1]]
    leftName <- allFormNames[1]
    for (righti in seq(2, length(allFormulasLists)))
    {
        rightName <- allFormNames[righti]

        printf("Merging %s with %s... ", paste0(allFormNames[seq_len(righti-1)], collapse = ","), rightName)

        rightFList <- allFormulasLists[[righti]]

        for (grp in union(names(consFormulaList), names(rightFList)))
        {
            if (is.null(rightFList[[grp]]))
                next # nothing to merge
            else if (is.null(consFormulaList[[grp]])) # not yet present
            {
                mTable <- rightFList[[grp]]

                # rename columns that should be unique from right to left
                unCols <- c(uniqueCols, c("formula", "byMSMS", "frag_formula", "mergedBy"))
                unCols <- unCols[sapply(unCols, function(uc) !is.null(mTable[[paste0(uc, "-", rightName)]]))]
                setnames(mTable, paste0(unCols, "-", rightName), paste0(unCols, "-", leftName))
            }
            else
            {
                haveLeftMSMS <- paste0("frag_formula-", leftName) %in% names(consFormulaList[[grp]])
                haveRightMSMS <- paste0("frag_formula-", rightName) %in% names(rightFList[[grp]])

                mergeCols <- c("formula", "byMSMS") # put byMSMS in there anyway in case only left/right has MSMS
                if (haveLeftMSMS && haveRightMSMS)
                    mergeCols <- c(mergeCols, "frag_formula")

                mTable <- merge(consFormulaList[[grp]], rightFList[[grp]], all = TRUE,
                                by.x = paste0(mergeCols, "-", leftName),
                                by.y = paste0(mergeCols, "-", rightName))

                if (!haveLeftMSMS && haveRightMSMS)
                    setnames(mTable, paste0("frag_formula-", rightName), paste0("frag_formula-", leftName))

                # remove duplicate columns that shouldn't
                for (col in uniqueCols)
                {
                    colLeft <- paste0(col, "-", leftName)
                    colRight <- paste0(col, "-", rightName)
                    if (!is.null(mTable[[colRight]]))
                    {
                        if (is.null(mTable[[colLeft]]))
                            setnames(mTable, colRight, colLeft)
                        else
                        {
                            mTable[, (colLeft) := ifelse(!is.na(get(colLeft)), get(colLeft), get(colRight))]
                            mTable[, (colRight) := NULL]
                        }
                    }
                }

                # collapse mergedBy
                ml <- paste0("mergedBy-", leftName); mr <- paste0("mergedBy-", rightName)
                mTable[!is.na(get(ml)), (ml) := ifelse(!is.na(get(mr)), paste(get(ml), get(mr), sep = ","), get(ml))]
                mTable[is.na(get(ml)), (ml) := get(mr)]
                mTable[, (mr) := NULL]
            }

            consFormulaList[[grp]] <- mTable
        }

        cat("Done!\n")
    }

    printf("Determining coverage... ")

    for (grpi in seq_along(consFormulaList))
    {
        # fix up de-duplicated column names
        deDupCols <- c(uniqueCols, "formula", "byMSMS", "frag_formula", "mergedBy")
        leftCols <- paste0(deDupCols, "-", leftName)
        deDupCols <- deDupCols[leftCols %in% names(consFormulaList[[grpi]])]
        leftCols <- leftCols[leftCols %in% names(consFormulaList[[grpi]])]
        if (length(leftCols) > 0)
            setnames(consFormulaList[[grpi]], leftCols, deDupCols)

        consFormulaList[[grpi]][, coverage := length(unique(unlist(strsplit(mergedBy, ",")))) / length(allFormulas), by = "formula"]

        if (relMinAbundance > 0)
            consFormulaList[[grpi]] <- consFormulaList[[grpi]][coverage >= relMinAbundance]
        else if (!is.null(uniqueFrom))
        {
            if (!is.character(uniqueFrom))
                uniqueFrom <- allFormNames[uniqueFrom]

            keep <- function(mergedBy)
            {
                mbs <- unique(unlist(strsplit(mergedBy, ",")))
                ret <- all(mbs %in% uniqueFrom) && (!uniqueOuter || length(mbs) == 1)
                return(rep(ret, length(mergedBy)))
            }

            consFormulaList[[grpi]] <- consFormulaList[[grpi]][consFormulaList[[grpi]][, keep(mergedBy), by = "formula"][[2]]]
        }

        rnames <- getAllFormulasCols("rankscore", names(consFormulaList[[grpi]]))
        consFormulaList[[grpi]][, rankscore := rowSums(.SD, na.rm = TRUE) / length(rnames), .SDcols = rnames]
        setorderv(consFormulaList[[grpi]], "rankscore", order = -1)
        consFormulaList[[grpi]][, c(rnames, "rankscore") := NULL]

        # consFormulaList[[grpi]] <- rankFormulaTable(consFormulaList[[grpi]])
    }

    consFormulaList <- pruneList(consFormulaList, checkZeroRows = TRUE)

    cat("Done!\n")

    return(formulas(formulas = consFormulaList, featureFormulas = list(),
                    algorithm = paste0(unique(sapply(allFormulas, algorithm)), collapse = ",")))
})


#' @templateVar func generateFormulas
#' @templateVar what generate formulae
#' @templateVar ex1 generateFormulasDA
#' @templateVar ex2 generateFormulasGenForm
#' @templateVar algos bruker,genform,sirius
#' @template generic-algo
#'
#' @param ... Any parameters to be passed to the selected formula generation
#'   algorithm.
#'
#' @rdname formula-generation
#' @aliases generateFormulas
#' @export
setMethod("generateFormulas", "featureGroups", function(fGroups, algorithm, ...)
{
    checkmate::assertChoice(algorithm, c("bruker", "genform", "sirius"))
    
    f <- switch(algorithm,
                bruker = generateFormulasDA,
                genform = generateFormulasGenForm,
                sirius = generateFormulasSIRIUS)

    f(fGroups, ...)
})
