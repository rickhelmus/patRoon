function setDetailsTablesRatio(fr1, fr2)
{
    let el = document.getElementById("detailsLayout");
    el.style["grid-template-rows"] = `auto ${fr1}fr ${fr2}fr`;
}

getViewIDFromSel = function(sel = undefined)
{
    if (sel === undefined)
        sel = document.getElementById("view-select").value;

    if (sel === "Suspects")
    {
        return (document.getElementById("viewSuspDetailsByGroup").checked) ? "SuspectsByGroup" : "SuspectsBySuspect";
    }

    if (sel === "ISTDs")
    {
        return (document.getElementById("viewSuspDetailsByGroup").checked) ? "ISTDsByGroup" : "ISTDsByISTD";
    }
    
    if (sel === "TPs")
    {
        if (document.getElementById("viewTPDetailsParents").checked)
            return "TPsParents";
        return (document.getElementById("viewSuspDetailsByGroup").checked) ? "TPsByGroup" : "TPsBySuspect";
    }
    
    return sel;
}

function initTabsInView(viewID)
{
    document.querySelectorAll('[detailsViewTabInit=' + viewID + '], [detailsViewTabInit=all]').forEach(function(el)
    {
        const meta = Reactable.getState(el.id).meta;
        meta.initTabFunc(el.id, viewID);
    });
}

function updateDetailsView(sel = undefined)
{
    const viewID = getViewIDFromSel(sel);
    
    let dl = document.getElementById("detailsLayout");
    dl.classList.forEach(cl => dl.classList.toggle(cl, !cl.startsWith("detailsLayout")));
    document.getElementById("detailsLayout").classList.add("detailsLayout" + viewID);

    // Toggle card elements: for these we need to modify the parent container generated by bslib
    document.querySelectorAll('[detailsViewOfParent]').forEach(function(el)
    {
        el.parentElement.classList.toggle("d-none", !el.getAttribute("detailsViewOfParent").split(' ').includes(viewID));
    });
    
    // Toggle other utility elements (eg parent/TP view)
    document.querySelectorAll('[detailsView]').forEach(function(el)
    {
        el.classList.toggle("d-none", !el.getAttribute("detailsView").split(' ').includes(viewID));
    });

    // Toggle view dependent bottombar tabs (eg susp annotation)
    document.getElementById("bottombarTabs").querySelectorAll('[detailsViewTab]').forEach(function(el)
    {
        toggleBottomTab(el, el.getAttribute("detailsViewTab").split(' ').includes(viewID));
    });
    
    initTabsInView(viewID);

    // UNDONE: Toggle elements with direct class set (parent/TP view, by group/susp view, susp only checkbox for annotations)
    // UNDONE: disable suspect filter for formulas/compounds if widget is not visible anymore
    // UNDONE: update bottom bar tabs from table row selections
}

function toggleBottomTab(tabEl, enable)
{
    // NOTE: tabEl is the title span element (see the R conditionalTabPanel() utility)
    let tabLiEl = tabEl.parentElement.parentElement;
    if (enable)
    {
        $(tabLiEl).show();
    }
    else
    {
        $(tabLiEl).hide();
        let tabAEl = tabEl.parentElement;
        // UNDONE: seems active class is not always applied on the same elements?
        if (tabLiEl.classList.contains("active") || tabAEl.classList.contains("active"))
        {
            // Activate features tab, assuming it is always available
            let featTab = document.getElementById("bottombarTabs").querySelector('[data-value="Features"]');
            $(featTab).tab("show");
            
            // remove active classes, seems to be that this needs to be done last
            tabLiEl.classList.remove("active");
            tabAEl.classList.remove("active");
        }
    }
}

function setTabSelFirstRow(tabID, findRowFunc)
{
    // activate first row
    // UNDONE: does this work properly with paging?
    const instData = Array.from(Reactable.getInstance(tabID).data);
    const firstRowInd = instData.findIndex(findRowFunc);
    Reactable.setMeta(tabID, { selectedRow: firstRowInd });
    Reactable.getState(tabID).meta.updateRowFunc(instData[firstRowInd], firstRowInd);
}

function updateTabSelFGroups(rowValues, rowIndex)
{
    const grp = rowValues.group;
    
    Reactable.setFilter('featuresTab', 'group', grp);
    
    if (document.getElementById('concsTab'))
        Reactable.setFilter('concsTab', 'group', grp);
    if (document.getElementById('toxTab'))
        Reactable.setFilter('toxTab', 'group', grp);
    
    let intEl = document.getElementById('int_plot');
    if (intEl)
        intEl.src = reportPlots.intPlots[grp];
    
    if (document.getElementById('MSPLTab'))
    {
        Reactable.setFilter('MSPLTab', 'group', grp);
        Reactable.setFilter('MSMSPLTab', 'group', grp);
        let specEl = document.getElementById('spectrumMS');
        if (specEl) // not present if !settings$MSPeakLists$spectra
        {
            // NOTE: undefined if filtered away
            specEl.src = (reportPlots.MSPeakLists[grp] && reportPlots.MSPeakLists[grp].MS) || "";
            document.getElementById('spectrumMSMS').src = (reportPlots.MSPeakLists[grp] && reportPlots.MSPeakLists[grp].MSMS) || "";
        }
    }

    for (ann of [ "formulas", "compounds" ])
    {
        if (document.getElementById(ann + "Tab"))
        {
            Reactable.setFilter(ann + "Tab", "group", grp);
            if (ann === "compounds")
                document.getElementById('openMF').href = Reactable.getState('compoundsTab').meta.mfWebLinks[grp];
        }
    }
    
    const ccd = document.getElementById('comps_cluster-dendro');
    if (ccd)
    {
        ccd.src = reportPlots.compsCluster[grp].dendro;
        Array.from(document.getElementsByClassName('mcs')).forEach(el => el.style.display = (el.classList.contains('mcs-' + grp)) ? '' : 'none');
    }
}

function updateTabSelFGroupsTPs(rowValues, rowIndex)
{
    updateTabSelFGroups(rowValues, rowIndex);
    
    if (Object.keys(reportPlots.TPs).length > 0)
    {
        const specSimEl = document.getElementById('similarity_spec');
        specSimEl.src = reportPlots.TPs[rowValues.cmpName][rowValues.cmpIndex - 1];
        specSimEl.style.display = ''; // may have been hidden if a previous img didn't exist
    }
    
    if (document.getElementById('similarityTab'))
        Reactable.setFilter('similarityTab', 'cmpID', rowValues.cmpName + '-' + rowValues.group);
}

function updateTabSelSusp(suspect, group)
{
    if (document.getElementById('suspInfoTab'))
        Reactable.setFilter('suspInfoTab', 'name', suspect);
    if (document.getElementById('suspAnnTab'))
        Reactable.setFilter('suspAnnTab', 'suspID', suspect + '-' + group);  

    for (ann of [ "formulas", "compounds" ])
    {
        const suspCheckEl = document.getElementById(ann + "-susp_only");
        if (!suspCheckEl)
            continue;
        Reactable.setMeta(ann + "Tab", { suspectFilter: suspect });
        if (!suspCheckEl.classList.contains("d-none") && suspCheckEl.checked)
            applyAnnSuspFilter(ann, suspect);
    }
}

function updateTabSelPlain(rowValues, rowIndex)
{
    updateTabSelFGroups(rowValues, rowIndex);
}

function updateTabSelSusByGroup(rowValues, rowIndex)
{
    updateTabSelFGroups(rowValues, rowIndex);
    Reactable.setFilter("detailsTabSusCandSuspect", "group", rowValues.group);
    setTabSelFirstRow("detailsTabSusCandSuspect", el => el.group === rowValues.group);
}

function updateTabSelSusCandSuspect(rowValues, rowIndex)
{
    updateTabSelSusp(rowValues.susp_name, rowValues.group);
}

function updateTabSelSusBySuspect(rowValues, rowIndex)
{
    Reactable.setFilter("detailsTabSusCandGroup", "susp_ID", rowValues.susp_name);
    setTabSelFirstRow("detailsTabSusCandGroup", el => el.susp_ID === rowValues.susp_name);
}

function updateTabSelSusCandGroup(rowValues, rowIndex)
{
    updateTabSelFGroups(rowValues, rowIndex);
    updateTabSelSusp(rowValues.susp_ID, rowValues.group);
}

function updateTabSelISTDsByGroup(rowValues, rowIndex)
{
    updateTabSelFGroups(rowValues, rowIndex);
    Reactable.setFilter("detailsTabISTDsCandISTD", "group", rowValues.group);
    setTabSelFirstRow("detailsTabISTDsCandISTD", el => el.group === rowValues.group);
}

function updateTabSelISTDsCandISTD(rowValues, rowIndex)
{
    if (document.getElementById('ISTDInfoTab'))
        Reactable.setFilter('ISTDInfoTab', 'name', rowValues.susp_name);
}

function updateTabSelISTDsByISTD(rowValues, rowIndex)
{
    Reactable.setFilter("detailsTabISTDsCandGroup", "susp_ID", rowValues.susp_name);
    setTabSelFirstRow("detailsTabISTDsCandGroup", el => el.susp_ID === rowValues.susp_name);
}

function updateTabSelISTDsCandGroup(rowValues, rowIndex)
{
    updateTabSelFGroups(rowValues, rowIndex);
    if (document.getElementById('ISTDInfoTab'))
        Reactable.setFilter('ISTDInfoTab', 'name', rowValues.susp_name);
}

function updateTabSelComponents(rowValues, rowIndex)
{
    updateTabSelFGroups(rowValues, rowIndex);
}

function updateTabSelTPsParents(rowValues, rowIndex)
{
    updateTabSelFGroups(rowValues, rowIndex);
    document.getElementById("TPCompon-select").value = rowValues.component;
    updateTPCompon(rowValues.component, false);
    updateTabSelSusp(rowValues.parent_name, rowValues.group);
}

function updateTabSelTPsByGroup(rowValues, rowIndex)
{
    updateTabSelFGroupsTPs(rowValues, rowIndex);
    if (document.getElementById("detailsTabTPsCandSuspect")) // FALSE if TPs were reported w/out candidates
    {
        Reactable.setFilter("detailsTabTPsCandSuspect", "group", rowValues.group);
        Reactable.setFilter("detailsTabTPsCandSuspect", "cmpName", rowValues.cmpName);
        setTabSelFirstRow("detailsTabTPsCandSuspect", el => el.cmpName === rowValues.cmpName && el.group === rowValues.group);
    }
}

function updateTabSelTPsCandSuspect(rowValues, rowIndex)
{
    updateTabSelSusp(rowValues.candidate_name, rowValues.group);
}

function updateTabSelTPsBySuspect(rowValues, rowIndex)
{
    Reactable.setFilter("detailsTabTPsCandGroup", "candidate_ID", rowValues.candidate_name);
    Reactable.setFilter("detailsTabTPsCandGroup", "cmpName", rowValues.cmpName);
    setTabSelFirstRow("detailsTabTPsCandGroup", el => el.cmpName === rowValues.cmpName && el.candidate_ID === rowValues.candidate_name);
}

function updateTabSelTPsCandGroup(rowValues, rowIndex)
{
    updateTabSelFGroupsTPs(rowValues, rowIndex);
    updateTabSelSusp(rowValues.candidate_ID, rowValues.group);
}

function initMainTabDefault(tabID, viewID)
{
    const meta = Reactable.getState(tabID).meta;
    const r = Reactable.getInstance(tabID).rowsById[meta.selectedRow];
    meta.updateRowFunc(r.values, r.index);
}

function initTabComponents(tabID, viewID)
{
    const cmpName = document.getElementById("Compon-select").value;
    setTabSelFirstRow(tabID, el => el.cmpName === cmpName);
    Reactable.setFilter(tabID, "cmpName", cmpName);
}

function initTabTPsParents(tabID, viewID)
{
    const cmpName = document.getElementById("TPCompon-select").value;
    // switch to the selected component
    setTabSelFirstRow(tabID, el => el.cmpName === cmpName);
}

function initTabTPs(tabID, viewID)
{
    const cmpName = document.getElementById("TPCompon-select").value;
    setTabSelFirstRow(tabID, el => el.cmpName === cmpName)
    Reactable.setFilter(tabID, "cmpName", cmpName);
}

function initTabAnn(tabID, viewID)
{
    const suspCheckEl = document.getElementById(ann + "-susp_only");
    // disable suspect filter if current view does not have suspects
    if (suspCheckEl.classList.contains("d-none"))
        toggleAnnSuspFilter(tabID.replace(/Tab$/, ""), false);
}

function showTabCols(id, columnGroup, show)
{
    const cols = Reactable.getState(id).meta.colToggles[columnGroup];
    if (Array.isArray(cols))
        cols.forEach(col => Reactable.toggleHideColumn(id, col, !show));
    else
        Reactable.toggleHideColumn(id, cols, !show);
    
    // UNDONE: don't do this here
    if (columnGroup === "chrom_large")
        Reactable.toggleHideColumn(id, "chrom_small", show);
}

function updateCompon(cmpName, activateFG = true)
{
    let chromEl = document.getElementById('chrom_view-component');
    let specEl = document.getElementById('spectrum_view-component');
    let profileRelEl = document.getElementById('profileRel_view-component');
    let profileAbsEl = document.getElementById('profileAbs_view-component');
    const pl = reportPlots.components.components[cmpName];
    chromEl.src = pl.chrom;
    specEl.src = pl.spec;
    if (profileRelEl != undefined)
    {
        profileRelEl.src = pl.profileRel;
        profileAbsEl.src = pl.profileAbs;
    }
    if (document.getElementById('componentInfoTab'))
        Reactable.setFilter('componentInfoTab', 'name', cmpName);

    if (activateFG)
        initTabsInView(getViewIDFromSel());
}

function updateTPCompon(cmpName, activateFG = true)
{
    const chromEl = document.getElementById('chrom_view-parent');
    const intEl = document.getElementById('int_plot-parent');
    const structEl = document.getElementById('struct_view-parent');
    
    if (chromEl)
        chromEl.src = reportPlots.chromsLarge[TPComponParentInfo[cmpName].group];
    if (intEl)
        intEl.src = reportPlots.intPlots[TPComponParentInfo[cmpName].group];
    if (structEl)
        structEl.src = reportPlots.structs[TPComponParentInfo[cmpName].InChIKey] || "";
    
    if (document.getElementById('parentSuspInfoTab'))
        Reactable.setFilter('parentSuspInfoTab', 'name', TPComponParentInfo[cmpName].name);
    if (document.getElementById('parentSuspAnnTab'))
        Reactable.setFilter('parentSuspAnnTab', 'suspID', TPComponParentInfo[cmpName].name + "-" + TPComponParentInfo[cmpName].group);
    
    showTPGraph(cmpName);

    if (activateFG)
        initTabsInView(getViewIDFromSel());
}

function advanceSelect(el, dir)
{
    // based on https://stackoverflow.com/a/11556996
    let newIndex = el.selectedIndex + dir;
    if (newIndex < 0)
        newIndex = el.options.length - 1;
    else if (newIndex >= el.options.length)
        newIndex = 0;
    el.options[newIndex].selected = true;
}

function advanceCompon(dir)
{
    let el = document.getElementById("Compon-select");
    advanceSelect(el, dir);
    updateCompon(el.value);
}

function advanceTPCompon(dir)
{
    let el = document.getElementById("TPCompon-select");
    advanceSelect(el, dir);
    updateTPCompon(el.value);
}

function showTPGraph(cmp)
{
    TPGraphs = document.querySelectorAll('[id ^= "TPGraph_"]');
    const elName = "TPGraph_" + cmp
    for (var i=0; i<TPGraphs.length; i++)
    {
        if (TPGraphs[i].id == elName && TPGraphs[i].children.length > 0) // NOTE: no children if plot couldn't be made
        {
            TPGraphs[i].style.display = "";
            document.getElementById("graphTPGraph_" + cmp).chart.fit(); // HACK: reset zoom
        }
        else
            TPGraphs[i].style.display = "none";
    }
}

function filtRangeModalInit(tab, col)
{
    const mname = "filter_" + col;
    const curF = Reactable.getState(tab).meta[mname];
    
    document.getElementById("filtNumMin").value = (curF == undefined) ? "" : curF[0];
    document.getElementById("filtNumMax").value = (curF == undefined) ? "" : curF[1];
    
    document.getElementById("filtNumApply").addEventListener("click", function(e)
    {
        const r = [ document.getElementById("filtNumMin").value, document.getElementById("filtNumMax").value ];
        Reactable.setFilter(tab, col, r);
        Reactable.setMeta(tab, { [mname]: r });
    }, { once: true });
    
    window.addEventListener('keydown', filtModalKeyHandler);
}

function filtModalKeyHandler(e)
{
    // based on https://stackoverflow.com/a/41055853
    if ($("#filterRangeModal").hasClass("show") && (e.keycode == 13 || e.which == 13))
    {
        document.getElementById("filtNumApply").click();
        window.removeEventListener('keydown', filtModalKeyHandler);    
    }
}

function filtNumClear()
{
    document.getElementById("filtNumMin").value = "";
    document.getElementById("filtNumMax").value = "";
    document.getElementById("filtNumApply").click();
}

function filtColSelModalInit(tab, col)
{
    // UNDONE: this always adds all (unique) values, including those that are e.g. filtered out due to group selection    
    const vals = new Set(Reactable.getState(tab).data.map(row => row[col]));
    
    filtSelModalInit(tab, col, vals);
}

function filtFeatAnnSelModalInit(tab)
{
    filtSelModalInit(tab, "annotations", [ "None", "MS2", "Formulas", "Compounds" ]);
}

function filtSelModalInit(tab, col, vals)
{
    const mname = "filter_" + col;
    const curF = Reactable.getState(tab).meta[mname];

    let lg = document.getElementById("filterSelectListGroup");
    while (lg.firstChild)
        lg.removeChild(lg.firstChild);

    let checkEls = [ ];
    vals.forEach(function(label)
    {
        let inpEl = document.createElement("input");
        inpEl.classList.add("form-check-input", "me-1");
        inpEl.type = "checkbox";
        inpEl.checked = curF == undefined || curF.has(label);
        
        let labEl = document.createElement("label");
        labEl.classList.add("list-group-item");
        labEl.appendChild(inpEl);
        labEl.appendChild(document.createTextNode(label));
        
        lg.appendChild(labEl);
        checkEls.push(inpEl);
    });
    
    document.getElementById("filtSelApply").addEventListener("click", function(e)
    {
        const checked = new Set();
        checkEls.forEach(function(cel)
        {
            if (cel.checked)
                checked.add(cel.nextSibling.textContent);
        });
        Reactable.setFilter(tab, col, checked);
        Reactable.setMeta(tab, { [mname]: checked });
    }, { once: true });
    
    //window.addEventListener('keydown', filtModalKeyHandler);
}

function filtSelModalToggleAll(e)
{
    Array.from(document.getElementById("filterSelectListGroup").children).forEach(el => el.children[0].checked = e);
}

function toggleTabFilters(tableID, e)
{
    const getFiltMeta = function(varn)
    {
        let ret = Reactable.getState(tableID).meta[varn];
        if (ret == undefined)
            return [ ];
        if (!Array.isArray(ret))
            return [ ret ];
        return ret;
    }
    
    const internFilterable = getFiltMeta("internFilterable");
    const neverFilterable = getFiltMeta("neverFilterable");

    const allColumns = Reactable.getInstance(tableID).allColumns;
    allColumns.forEach(function(col)
    {
        if (!internFilterable.includes(col.id) && !neverFilterable.includes(col.id))
            col.filterable = e;
    })
    
    // HACK: setting a filter will toggle the visibility if all filters were enabled/disabled
    // NOTE: this somehow will reset all filter values, so restore internal filters if needed...
    
    let curInternFilters;
    curInternFilters = internFilterable.map(col => Reactable.getInstance(tableID).allColumns.find(c => c.id === col).filterValue);
    Reactable.setFilter(tableID, allColumns[0].id, undefined);
    internFilterable.forEach(function(col, index) { Reactable.setFilter(tableID, col, curInternFilters[index]); } );
}

function applyAnnSuspFilter(ann, suspect = undefined)
{
    const elName = ann + "Tab";
    if (suspect === undefined)
        suspect = Reactable.getState(elName).meta.suspectFilter;
    Reactable.setFilter(elName, "suspect", suspect);
}

function toggleAnnSuspFilter(ann, e)
{
    if (!e)
        Reactable.setFilter(ann + "Tab", "suspect", undefined);
    else
        applyAnnSuspFilter(ann)
}

function setTabGroupBy(tab, gb, expBtn = undefined)
{
    Reactable.setGroupBy(tab, [ gb ]);
    
    if (expBtn)
    {
        // hide toggle expand button if no grouping
        document.getElementById(expBtn).style.display = (gb === "") ? "none" : "";
    }
}

function downloadCSV(tab, out)
{
    const cols = Reactable.getState(tab).meta.CSVCols;
    Reactable.downloadDataCSV(tab, out, { columnIds: cols });
}


$(document).ready(function() {
    // Image zooming, based on https://stackoverflow.com/a/57694495
    $('body').prepend("<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>");
    $('body').on('click', 'img:not(.zoomImg, .noZoomImg)', function() {
        const src = $(this).attr('data-srcZoom') || $(this).attr('src');
        $('.zoomImg').attr('src', src);
        $('.zoomDiv').css({opacity: '1', width: '70%'});
    });
    $('img.zoomImg').click(function() {
        $('.zoomDiv').css({opacity: '0', width: '0%'});
    });
    
    updateDetailsView("Plain");

    let el = document.getElementById("Compon-select")
    if (el)
        updateCompon(el.options[0].value, false);
        
    el = document.getElementById("TPCompon-select")
    if (el)
        updateTPCompon(el.options[0].value, false);
    
    document.getElementById("filterRangeModal").addEventListener('shown.bs.modal', () => {
        document.getElementById("filtNumMin").focus();
    });
});
