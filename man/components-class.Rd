% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/components.R, R/components-camera.R,
%   R/components-features.R, R/components-cliquems.R, R/components-set.R,
%   R/components-openms.R, R/components-ramclustr.R
\docType{class}
\name{components-class}
\alias{components-class}
\alias{components}
\alias{componentTable,components-method}
\alias{componentTable}
\alias{componentInfo,components-method}
\alias{componentInfo}
\alias{groupNames,components-method}
\alias{length,components-method}
\alias{names,components-method}
\alias{show,components-method}
\alias{[,components,ANY,ANY,missing-method}
\alias{[[,components,ANY,ANY-method}
\alias{$,components-method}
\alias{delete,components-method}
\alias{as.data.table,components-method}
\alias{filter,components-method}
\alias{findFGroup,components-method}
\alias{findFGroup}
\alias{plotSpectrum,components-method}
\alias{plotChroms,components-method}
\alias{consensus,components-method}
\alias{componentsCamera-class}
\alias{componentsCamera}
\alias{componentsFeatures-class}
\alias{componentsFeatures}
\alias{show,componentsFeatures-method}
\alias{componentsCliqueMS-class}
\alias{componentsCliqueMS}
\alias{componentsSet-class}
\alias{componentsSet}
\alias{show,componentsSet-method}
\alias{[,componentsSet,ANY,ANY,missing-method}
\alias{filter,componentsSet-method}
\alias{delete,componentsSet-method}
\alias{consensus,componentsSet-method}
\alias{componentsUnset-class}
\alias{componentsUnset}
\alias{unset,componentsSet-method}
\alias{componentsOpenMS-class}
\alias{componentsOpenMS}
\alias{componentsRC-class}
\alias{componentsRC}
\title{Component class}
\usage{
\S4method{componentTable}{components}(obj)

\S4method{componentInfo}{components}(obj)

\S4method{groupNames}{components}(obj)

\S4method{length}{components}(x)

\S4method{names}{components}(x)

\S4method{show}{components}(object)

\S4method{[}{components,ANY,ANY,missing}(x, i, j, ..., drop = TRUE)

\S4method{[[}{components,ANY,ANY}(x, i, j)

\S4method{$}{components}(x, name)

\S4method{delete}{components}(obj, i = NULL, j = NULL, ...)

\S4method{as.data.table}{components}(x)

\S4method{filter}{components}(
  obj,
  size = NULL,
  adducts = NULL,
  isotopes = NULL,
  rtIncrement = NULL,
  mzIncrement = NULL,
  checkComponentsSession = NULL,
  negate = FALSE,
  verbose = TRUE
)

\S4method{findFGroup}{components}(obj, fGroup)

\S4method{plotSpectrum}{components}(obj, index, markFGroup = NULL, xlim = NULL, ylim = NULL, ...)

\S4method{plotChroms}{components}(obj, index, fGroups, rtWindow = 5, ...)

\S4method{consensus}{components}(obj, ...)

\S4method{show}{componentsFeatures}(object)

\S4method{show}{componentsSet}(object)

\S4method{[}{componentsSet,ANY,ANY,missing}(x, i, j, ..., sets = NULL, drop = TRUE)

\S4method{filter}{componentsSet}(obj, ..., negate = FALSE, sets = NULL)

\S4method{delete}{componentsSet}(obj, i = NULL, j = NULL, ...)

\S4method{consensus}{componentsSet}(obj, ...)

\S4method{unset}{componentsSet}(obj, set)
}
\arguments{
\item{obj, object, x}{The \code{component} object.}

\item{i, j}{For \code{[}/\code{[[}: A numeric or character value which is used to select components/feature groups by
their index or name, respectively (for the order/names see \code{names()/groupNames()}).\cr\cr For \code{[}: Can also be logical to perform logical selection
(similar to regular vectors). If missing all components/feature groups are selected.\cr\cr For \code{[[}: should be a scalar value. \code{j} is optional.\cr\cr For \code{delete}: The data to remove from. \code{i} are the
components as numeric index, logical or character, \code{j} the feature groups as numeric index/logical (relative to component) or character. If either is
\code{NULL} then data for all is removed. \code{j} may also be a function: it will be called for each component,
with the component (a \code{data.table}), the component name and any other arguments passed as \code{\dots} to \code{delete}. The return value of this
function specifies the feature groups to be removed (same format as \code{j}).}

\item{\dots}{For \code{delete}: passed to the function specified as \code{j}.

  For \code{plotChroms}: Further (optional) arguments passed to the
  \code{plotChroms} method for the \code{\link{featureGroups}} class. Note that
  the \code{colourBy}, \code{showPeakArea}, \code{showFGroupRect} and
  \code{topMost} arguments cannot be set as these are set by this method.

  For \code{plotSpectrum}: Further arguments passed to
  \code{\link[graphics]{plot}}.

  For \code{consensus}: \code{components} objects that should be used to
  generate the consensus.
  
  \setsPassedArgs1{components}}

\item{drop}{ignored.}

\item{name}{The component name (partially matched).}

\item{size}{Should be a two sized vector with the minimum/maximum size of a component. Set to \code{NULL} to ignore.}

\item{adducts}{Remove any feature groups within components that do not match given adduct rules. If \code{adducts} is
a logical then only results are kept when an adduct is assigned (\code{adducts=TRUE}) or not assigned
(\code{adducts=FALSE}). Otherwise, if \code{adducts} contains one or more \code{\link{adduct}} objects (or
something that can be converted to it with \code{\link{as.adduct}}) then only results are kept that match the given
adducts. Set to \code{NULL} to ignore this filter.}

\item{isotopes}{Only keep results that match a given isotope rule. If \code{isotopes} is a logical then only results
are kept with (\code{isotopes=TRUE}) or without (\code{isotopes=FALSE}) isotope assignment. Otherwise
\code{isotopes} should be a numeric vector with isotope identifiers to keep (\emph{e.g.} \samp{0} for monoisotopic
results, \samp{1} for \samp{M+1} results etc.). Set to \code{NULL} to ignore this filter.}

\item{rtIncrement, mzIncrement}{Should be a two sized vector with the minimum/maximum retention or mz increment of a
homologous series. Set to \code{NULL} to ignore.}

\item{checkComponentsSession}{If set then components and/or feature groups are removed that were selected for removal
(see \link{check-GUI} and the \code{\link{checkComponents}} function). The value of \code{checkComponentsSession}
should either by a path to the session file or \code{TRUE}, in which case the default session file name is used. If
\code{negate=TRUE} then all non-selected data is removed instead.}

\item{negate}{If \code{TRUE} then filters are applied in opposite manner.}

\item{verbose}{If set to \code{FALSE} then no text output is shown.}

\item{fGroup}{The name (thus a character) of the feature group that should be
searched for.}

\item{index}{The index of the component. Can be a numeric index or a
character with its name.}

\item{markFGroup}{If specified (\emph{i.e.} not \code{NULL}) this argument
can be used to mark a feature group in the plotted spectrum. The value
should be a character with the name of the feature group. Setting this to
\code{NULL} will not mark any peak.}

\item{xlim, ylim}{Sets the plot size limits used by
\code{\link[graphics]{plot}}. Set to \code{NULL} for automatic plot sizing.}

\item{fGroups}{The \code{\link{featureGroups}} object that was used to
generate the components.}

\item{rtWindow}{Retention window: see the \code{plotChroms} method for the
\code{\link{featureGroups}} class.}

\item{sets}{\setsWF A \code{character} with name(s) of the sets to keep (or remove if \code{negate=TRUE}).}

\item{set}{\setsWF The name of the set.}
}
\value{
\code{delete} returns the object for which the specified data was removed.

\code{consensus} returns a \code{components} object that is produced
  by merging multiple specified \code{components} objects.
}
\description{
Contains data for feature groups that are related in some way. These
\emph{components} commonly include adducts, isotopes and homologues.
}
\details{
\code{components} objects are obtained from \code{\link{generateComponents}}.
}
\section{Methods (by generic)}{
\itemize{
\item \code{componentTable(components)}: Accessor method for the \code{components} slot of a
\code{components} class. Each component is stored as a
\code{\link{data.table}}.

\item \code{componentInfo(components)}: Accessor method for the \code{componentInfo} slot of a
\code{components} class.

\item \code{groupNames(components)}: returns a \code{character} vector with the names of the
feature groups for which data is present in this object.

\item \code{length(components)}: Obtain total number of components.

\item \code{names(components)}: Obtain the names of all components.

\item \code{show(components)}: Show summary information for this object.

\item \code{x[i}: Subset on components/feature groups.

\item \code{x[[i}: Extracts a component table, optionally filtered by a feature group.

\item \code{$}: Extracts a component table by component name.

\item \code{delete(components)}: Completely deletes specified (parts of) components.

\item \code{as.data.table(components)}: Returns all component data in a table.

\item \code{filter(components)}: Provides rule based filtering for components.

\item \code{findFGroup(components)}: Returns the component id(s) to which a feature group
belongs.

\item \code{plotSpectrum(components)}: Plot a \emph{pseudo} mass spectrum for a single
component.

\item \code{plotChroms(components)}: Plot an extracted ion chromatogram (EIC) for all
feature groups within a single component.

\item \code{consensus(components)}: Generates a consensus from multiple \code{components}
objects. At this point results are simply combined and no attempt is made to
merge similar components.

}}
\section{Slots}{

\describe{
\item{\code{components}}{List of all components in this object. Use the
\code{componentTable} method for access.}

\item{\code{componentInfo}}{A \code{\link{data.table}} containing general information
for each component. Use the \code{componentInfo} method for access.}
}}

\note{
\code{filter} Applies only those filters for which a component has data available. For instance, filtering by
  adduct will only filter any results within a component if that component contains adduct information.
}
\section{S4 class hierarchy}{
 \itemize{   \item{\code{\link{workflowStep}}}   \itemize{     \item{\strong{\code{\link{components}}}}     \itemize{       \item{\code{\link{componentsCamera}}}       \item{\code{\link{componentsFeatures}}}       \itemize{         \item{\code{\link{componentsCliqueMS}}}         \item{\code{\link{componentsOpenMS}}}       }       \item{\code{\link{componentsClust}}}       \itemize{         \item{\code{\link{componentsIntClust}}}         \item{\code{\link{componentsSpecClust}}}       }       \item{\code{\link{componentsSet}}}       \itemize{         \item{\code{\link{componentsNTSet}}}       }       \item{\code{\link{componentsUnset}}}       \item{\code{\link{componentsNT}}}       \itemize{         \item{\code{\link{componentsNTUnset}}}       }       \item{\code{\link{componentsRC}}}       \item{\code{\link{componentsTPs}}}     }   } }
}

\section{Sets workflows}{
 \setsWFClass{componentsSet}{components}

  \setsWFNewMethodsSO{componentsUnset}{Only the components in the specified set are kept.}

  \setsWFChangedMethods{

  \item \code{filter} and the subset operator (\code{[}) Can be used to select components that are only present for
  selected sets.

  }
}

\seealso{
\code{\link{generateComponents}}
}
