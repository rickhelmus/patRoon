% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R, R/feature_groups.R,
%   R/feature_groups-set.R, R/feature_groups-bruker.R,
%   R/feature_groups-envimass.R, R/feature_groups-kpic2.R,
%   R/feature_groups-openms.R, R/feature_groups-plot.R,
%   R/feature_groups-sirius.R, R/feature_groups-xcms.R, R/feature_groups-xcms3.R
\docType{class}
\name{groupTable}
\alias{groupTable}
\alias{groupFeatIndex}
\alias{groupInfo}
\alias{unique}
\alias{overlap}
\alias{selectIons}
\alias{groupQualities}
\alias{groupScores}
\alias{internalStandards}
\alias{internalStandardAssignments}
\alias{normInts}
\alias{featureGroups-class}
\alias{featureGroups}
\alias{names,featureGroups-method}
\alias{analyses,featureGroups-method}
\alias{replicateGroups,featureGroups-method}
\alias{groupNames,featureGroups-method}
\alias{length,featureGroups-method}
\alias{show,featureGroups-method}
\alias{groupTable,featureGroups-method}
\alias{analysisInfo,featureGroups-method}
\alias{groupInfo,featureGroups-method}
\alias{featureTable,featureGroups-method}
\alias{getFeatures,featureGroups-method}
\alias{groupFeatIndex,featureGroups-method}
\alias{groupQualities,featureGroups-method}
\alias{groupScores,featureGroups-method}
\alias{annotations,featureGroups-method}
\alias{internalStandards,featureGroups-method}
\alias{internalStandardAssignments,featureGroups-method}
\alias{adducts,featureGroups-method}
\alias{adducts<-,featureGroups-method}
\alias{concentrations,featureGroups-method}
\alias{concentrations}
\alias{toxicities,featureGroups-method}
\alias{toxicities}
\alias{[,featureGroups,ANY,ANY,missing-method}
\alias{[[,featureGroups,ANY,ANY-method}
\alias{$,featureGroups-method}
\alias{delete,featureGroups-method}
\alias{export,featureGroups-method}
\alias{as.data.table,featureGroups-method}
\alias{unique,featureGroups-method}
\alias{overlap,featureGroups-method}
\alias{calculatePeakQualities,featureGroups-method}
\alias{selectIons,featureGroups-method}
\alias{normInts,featureGroups-method}
\alias{getTICs,featureGroups-method}
\alias{getTICs}
\alias{getBPCs,featureGroups-method}
\alias{getBPCs}
\alias{featureGroupsSet-class}
\alias{featureGroupsSet}
\alias{sets,featureGroupsSet-method}
\alias{internalStandardAssignments,featureGroupsSet-method}
\alias{adducts,featureGroupsSet-method}
\alias{adducts<-,featureGroupsSet-method}
\alias{delete,featureGroupsSet-method}
\alias{show,featureGroupsSet-method}
\alias{featureTable,featureGroupsSet-method}
\alias{[,featureGroupsSet,ANY,ANY,missing-method}
\alias{export,featureGroupsSet-method}
\alias{unique,featureGroupsSet-method}
\alias{overlap,featureGroupsSet-method}
\alias{selectIons,featureGroupsSet-method}
\alias{normInts,featureGroupsSet-method}
\alias{featureGroupsUnset-class}
\alias{featureGroupsUnset}
\alias{unset,featureGroupsSet-method}
\alias{featureGroupsBruker-class}
\alias{featureGroupsBruker}
\alias{featureGroupsEnviMass-class}
\alias{featureGroupsEnviMass}
\alias{featureGroupsKPIC2-class}
\alias{featureGroupsKPIC2}
\alias{delete,featureGroupsKPIC2-method}
\alias{featureGroupsOpenMS-class}
\alias{featureGroupsOpenMS}
\alias{plotTICs,featureGroups-method}
\alias{plotTICs}
\alias{plotBPCs,featureGroups-method}
\alias{plotBPCs}
\alias{featureGroupsSIRIUS-class}
\alias{featureGroupsSIRIUS}
\alias{featureGroupsXCMS-class}
\alias{featureGroupsXCMS}
\alias{delete,featureGroupsXCMS-method}
\alias{featureGroupsXCMS3-class}
\alias{featureGroupsXCMS3}
\alias{delete,featureGroupsXCMS3-method}
\title{Base class for grouped features.}
\usage{
groupTable(object, ...)

groupFeatIndex(fGroups)

groupInfo(fGroups)

unique(x, incomparables = FALSE, ...)

overlap(fGroups, which, exclusive = FALSE, ...)

selectIons(fGroups, components, prefAdduct, ...)

groupQualities(fGroups)

groupScores(fGroups)

internalStandards(fGroups)

internalStandardAssignments(fGroups, ...)

normInts(
  fGroups,
  featNorm = "none",
  groupNorm = FALSE,
  normFunc = max,
  standards = NULL,
  ISTDRTWindow = 120,
  ISTDMZWindow = 300,
  minISTDs = 3,
  ...
)

\S4method{names}{featureGroups}(x)

\S4method{analyses}{featureGroups}(obj)

\S4method{replicateGroups}{featureGroups}(obj)

\S4method{groupNames}{featureGroups}(obj)

\S4method{length}{featureGroups}(x)

\S4method{show}{featureGroups}(object)

\S4method{groupTable}{featureGroups}(object, areas = FALSE, normalized = FALSE)

\S4method{analysisInfo}{featureGroups}(obj)

\S4method{groupInfo}{featureGroups}(fGroups)

\S4method{featureTable}{featureGroups}(obj)

\S4method{getFeatures}{featureGroups}(obj)

\S4method{groupFeatIndex}{featureGroups}(fGroups)

\S4method{groupQualities}{featureGroups}(fGroups)

\S4method{groupScores}{featureGroups}(fGroups)

\S4method{annotations}{featureGroups}(obj)

\S4method{internalStandards}{featureGroups}(fGroups)

\S4method{internalStandardAssignments}{featureGroups}(fGroups)

\S4method{adducts}{featureGroups}(obj)

\S4method{adducts}{featureGroups}(obj) <- value

\S4method{concentrations}{featureGroups}(fGroups)

\S4method{toxicities}{featureGroups}(fGroups)

\S4method{[}{featureGroups,ANY,ANY,missing}(x, i, j, ..., rGroups, results, drop = TRUE)

\S4method{[[}{featureGroups,ANY,ANY}(x, i, j)

\S4method{$}{featureGroups}(x, name)

\S4method{delete}{featureGroups}(obj, i = NULL, j = NULL, ...)

\S4method{export}{featureGroups}(obj, type, out)

\S4method{as.data.table}{featureGroups}(
  x,
  average = FALSE,
  areas = FALSE,
  features = FALSE,
  qualities = FALSE,
  regression = FALSE,
  averageFunc = mean,
  normalized = FALSE,
  FCParams = NULL,
  concAggrParams = getDefPredAggrParams(),
  toxAggrParams = getDefPredAggrParams(),
  normConcToTox = FALSE
)

\S4method{unique}{featureGroups}(x, which, relativeTo = NULL, outer = FALSE)

\S4method{overlap}{featureGroups}(fGroups, which, exclusive)

\S4method{calculatePeakQualities}{featureGroups}(
  obj,
  weights,
  flatnessFactor,
  avgFunc = mean,
  parallel = TRUE
)

\S4method{selectIons}{featureGroups}(
  fGroups,
  components,
  prefAdduct,
  onlyMonoIso = TRUE,
  chargeMismatch = "adduct"
)

\S4method{normInts}{featureGroups}(
  fGroups,
  featNorm = "none",
  groupNorm = FALSE,
  normFunc = max,
  standards = NULL,
  ISTDRTWindow = 120,
  ISTDMZWindow = 300,
  minISTDs = 3,
  ...
)

\S4method{getTICs}{featureGroups}(obj, retentionRange = NULL, MSLevel = c(1, 2))

\S4method{getBPCs}{featureGroups}(obj, retentionRange = NULL, MSLevel = c(1, 2))

\S4method{sets}{featureGroupsSet}(obj)

\S4method{internalStandardAssignments}{featureGroupsSet}(fGroups, set = NULL)

\S4method{adducts}{featureGroupsSet}(obj, set, ...)

\S4method{adducts}{featureGroupsSet}(obj, set, reGroup = TRUE) <- value

\S4method{delete}{featureGroupsSet}(obj, i = NULL, j = NULL, ...)

\S4method{show}{featureGroupsSet}(object)

\S4method{featureTable}{featureGroupsSet}(obj)

\S4method{[}{featureGroupsSet,ANY,ANY,missing}(x, i, j, ..., rGroups, sets = NULL, drop = TRUE)

\S4method{export}{featureGroupsSet}(obj, type, out, set)

\S4method{unique}{featureGroupsSet}(x, which, ..., sets = FALSE)

\S4method{overlap}{featureGroupsSet}(fGroups, which, exclusive, sets = FALSE)

\S4method{selectIons}{featureGroupsSet}(fGroups, components, prefAdduct, ...)

\S4method{normInts}{featureGroupsSet}(
  fGroups,
  featNorm = "none",
  groupNorm = FALSE,
  normFunc = max,
  standards = NULL,
  ISTDRTWindow = 120,
  ISTDMZWindow = 300,
  minISTDs = 3,
  ...
)

\S4method{unset}{featureGroupsSet}(obj, set)

\S4method{delete}{featureGroupsKPIC2}(obj, ...)

\S4method{plotTICs}{featureGroups}(
  obj,
  retentionRange = NULL,
  MSLevel = 1,
  retMin = FALSE,
  title = NULL,
  colourBy = c("none", "analyses", "rGroups"),
  showLegend = TRUE,
  xlim = NULL,
  ylim = NULL,
  ...
)

\S4method{plotBPCs}{featureGroups}(
  obj,
  retentionRange = NULL,
  MSLevel = 1,
  retMin = FALSE,
  title = NULL,
  colourBy = c("none", "analyses", "rGroups"),
  showLegend = TRUE,
  xlim = NULL,
  ylim = NULL,
  ...
)

\S4method{delete}{featureGroupsXCMS}(obj, ...)

\S4method{delete}{featureGroupsXCMS3}(obj, ...)
}
\arguments{
\item{\dots}{For the \code{"["} operator: ignored.

  For \code{delete}: passed to the function specified as \code{j}.

  For \code{normInts}: passed to \code{\link{screenSuspects}} if \code{featNorm="istd"}.

  \setsPassedArgs1{featureGroups}}

\item{fGroups, obj, x, object}{\code{featureGroups} object to be accessed.}

\item{which}{A character vector with replicate groups used for comparison.

  For \code{overlap}: can also be a \code{list} of \code{character} vectors with replicate groups to compare. For
  instance, \code{which=list(c("samp1", "samp2"), c("samp3", "samp4"))} returns the overlap between
  \code{"samp1"}+\code{"samp2"} and \code{"samp3"}+\code{"samp4"}.}

\item{exclusive}{If \code{TRUE} then all feature groups are removed that are
not unique to the given replicate groups.}

\item{components}{The \code{components} object that was generated for the given \code{featureGroups} object.
Obviously, the components must be created with algorithms that support adduct/isotope annotations, such as those
from \pkg{RAMClustR} and \pkg{cliqueMS}.}

\item{prefAdduct}{The 'preferred adduct' (see method description). This is often \code{"[M+H]+"} or \code{"[M-H]-"}.}

\item{featNorm}{The method applied for feature normalization: \code{"istd"}, \code{"tic"}, \code{"conc"} or
\code{"none"}. See the \verb{Feature intensity normalization} section for details.}

\item{groupNorm}{If \code{TRUE} then group normalization is performed. See the \verb{Feature intensity normalization}
section for details.}

\item{normFunc}{A \code{function} to combine data for normalization. See the \verb{Feature intensity normalization}
section for details.}

\item{standards}{A \code{data.table} (or \code{data.frame}) with all internal standards. Should follow the format of
  a \link[=suspect-screening]{suspect list}. Only used if \code{featNorm="istd"}. See the \verb{Feature intensity
  normalization} section for details.

  \setsWF Can also be a \code{list} with internal standard lists.

  See the \code{suspects} argument to \code{\link{screenSuspects}} for more details.}

\item{ISTDRTWindow, ISTDMZWindow}{The retention time and \emph{m/z} windows for IS selection. Only used if
\code{featNorm="istd"}. See the \verb{Feature intensity normalization} section for details.}

\item{minISTDs}{The minimum number of IS that should be assigned to each feature (if possible). Only used if
\code{featNorm="istd"}. See the \verb{Feature intensity normalization} section for details.}

\item{areas}{If set to \code{TRUE} then areas are considered instead of peak intensities.

  For \code{as.data.table}: ignored if \code{features=TRUE}, as areas of features are always reported.}

\item{normalized}{If \code{TRUE} then normalized intensity data is used (see the \verb{Feature intensity
  normalization} section.

  For \code{as.data.table}: if no normalization data is available (\emph{e.g.} because \code{normInts} was not used)
  then an automatic group normalization is performed.}

\item{value}{For \code{adducts<-}: A \code{character} with adduct annotations assigned to each feature group. The
length should equal the number of feature groups. Can be named with feature group names to customize the assignment
order.}

\item{i, j}{For \code{[}/\code{[[}: A numeric or character value which is used to select analyses/feature groups by
their index or name, respectively (for the order/names see \code{analyses()/names()}).\cr\cr For \code{[}: Can also be logical to perform logical selection
(similar to regular vectors). If missing all analyses/feature groups are selected.\cr\cr For \code{[[}: should be a scalar value. If \code{j} is not specified, \code{i} selects by feature groups instead.\cr\cr For \code{delete}: The data to remove from. \code{i} are the
analyses as numeric index, logical or character, \code{j} the feature groups as numeric index, logical or character. If either is
\code{NULL} then data for all is removed. \code{j} may also be a function: it will be called for each feature group,
with a vector of the group intensities, the group name and any other arguments passed as \code{\dots} to \code{delete}. The return value of this
function specifies the analyses of the features in the group to be removed (same format as \code{i}).}

\item{rGroups}{For \code{[}: An optional \code{character} vector: if specified only keep results for the given
replicate groups (equivalent to the \code{rGroups} argument to \code{\link[=filter,featureGroups-method]{filter}}).}

\item{results}{Optional argument. If specified only feature groups with results in the specified object are kept. The
class of \code{results} should be \code{\link{featureAnnotations}} or \code{\link{components}}. Multiple objects
can be specified in a \code{list}: in this case a feature group is kept if it has a result in \emph{any} of the
objects (equivalent to the \code{results} argument to \code{\link[=filter,featureGroups-method]{filter}}).}

\item{drop}{ignored.}

\item{name}{The feature group name (partially matched).}

\item{type}{The export type: \code{"brukerpa"} (Bruker ProfileAnalysis), \code{"brukertasq"} (Bruker TASQ) or
\code{"mzmine"} (MZmine).}

\item{out}{The destination file for the exported data.}

\item{average}{If \code{TRUE} then data within replicate groups are averaged.

  For \code{as.data.table}: if \code{features=TRUE} other feature properties are also averaged.}

\item{features}{If \code{TRUE} then feature specific data will be added. If \code{average=TRUE} this data will be
averaged for each feature group.}

\item{qualities}{Adds feature (group) qualities (\code{qualities="quality"}), scores (\code{qualities="score"}) or
both (\code{qualities="both"}), if this data is available (\emph{i.e.} from \code{calculatePeakQualities}). If
\code{qualities=FALSE} then nothing is reported.}

\item{regression}{Set to \code{TRUE} to add regression data for each feature group. For this a linear model is
created (intensity/area [depending on \code{areas} argument] \emph{vs} concentration). The model concentrations
(e.g. of a set of standards) is derived from the \code{conc} column of the \link[=analysis-information]{analysis
information}. From this model the intercept, slope and R2 is added to the output. In addition, when
\code{features=TRUE}, concentrations for each feature are added. Note that no regression information is added when
no \code{conc} column is present in the analysis information or when less than two concentrations are specified
(\emph{i.e.} the minimum amount).}

\item{averageFunc}{Function used for averaging. Only used when \code{average=TRUE} or \code{FCParams != NULL}.}

\item{FCParams}{A parameter list to calculate Fold change data. See \code{getFCParams} for more details. Set to
\code{NULL} to not perform FC calculations.}

\item{concAggrParams, toxAggrParams}{Parameters to aggregate calculated concentrations/toxicities (obtained with
\code{\link{calculateConcs}}/\code{\link{calculateTox}}). See \link[=pred-aggr-params]{prediction aggregation
parameters} for more information. Set to \code{NULL} to omit this data.}

\item{normConcToTox}{Set to \code{TRUE} to normalize concentrations to toxicities. Only relevant if this data is
present (see \code{\link{calculateConcs}}/\code{\link{calculateTox}}).}

\item{relativeTo}{A character vector with replicate groups that should be
used for unique comparison. If \code{NULL} then all replicate groups are
used for comparison. Replicate groups specified in \code{which} are
ignored.}

\item{outer}{If \code{TRUE} then only feature groups are kept which do not
overlap between the specified replicate groups for the \code{which}
parameter.}

\item{weights}{A named \code{numeric} vector that defines the weight for each score to calculate the
\verb{totalScore}. The names of the vector follow the score names. Unspecified weights are defaulted to \samp{1}.
Example: \code{weights=c(ApexBoundaryRatioScore=0.5, GaussianSimilarityScore=2)}.}

\item{flatnessFactor}{Passed to \pkg{MetaClean} as the \code{flatness.factor} argument to
\code{\link[MetaClean]{calculateJaggedness}} and \code{\link[MetaClean]{calculateModality}}.}

\item{avgFunc}{The function used to average the peak qualities and scores for each feature group.}

\item{parallel}{If set to \code{TRUE} then code is executed in parallel through the \CRANpkg{futures} package. Please
see the parallelization section in the handbook for more details.}

\item{onlyMonoIso}{Set to \code{TRUE} to only keep feature groups that were annotated as monoisotopic. Feature groups
are never removed by this setting if no isotope annotations are available.}

\item{chargeMismatch}{Specifies how to deal with a mismatch in charge between adduct and isotope annotations. Valid
values are: \code{"adduct"} (ignore isotope annotation), \code{"isotope"} (ignore adduct annotation), \code{"none"}
(ignore both annotations) and \code{"ignore"} (don't check for charge mismatches). \emph{Important}: when
\command{OpenMS} is used to find features, it already removes any detected non-monoisotopic features by default.
Hence, in such case setting \code{chargeMismatch="adduct"} is more appropriate.}

\item{retentionRange}{Range of retention time (in seconds) to collect TIC traces.
Should be a numeric vector with length of two containing the min/max values. 
Set to NULL to ignore.}

\item{MSLevel}{Integer vector with the ms levels (i.e., 1 for MS1 and 2 for MS2) 
to obtain TIC traces.}

\item{set}{\setsWF The name of the set.}

\item{reGroup}{\setsWF Set to \code{TRUE} to re-group the features after the adduct annotations are changed. See the
\verb{Sets workflow} section for more details.}

\item{sets}{\setsWF For \code{[}: a \code{character} with name(s) of the sets to keep.

  For \code{overlap} and \code{unique}: If \code{TRUE} then the \code{which} argument changes its meaning and is used
  to specify the names of the sets to be compared.}

\item{retMin}{Plot retention time in minutes (instead of seconds).}

\item{title}{Character string used for title of the plot. If \code{NULL} a title will be automatically generated.}

\item{colourBy}{Sets the automatic colour selection: "none" for a single 
colour or "analyses"/"rGroups" for a distinct colour per analysis or analysis replicate group.}

\item{showLegend}{Plot a legend if TRUE.}

\item{xlim, ylim}{Sets the plot size limits used by
\code{\link[graphics]{plot}}. Set to \code{NULL} for automatic plot sizing.}
}
\value{
\code{delete} returns the object for which the specified data was removed.

\code{calculatePeakQualities} returns a modified object amended with peak qualities and scores.

\code{selectIons} returns a \code{featureGroups} object with only the selected feature groups and amended
  with adduct annotations.

\code{normInts} returns a \code{featureGroups} object, amended with data in the \code{ISTDs} and
  \code{ISTDAssignments} slots if \code{featNorm="istd"}.
}
\description{
This class holds all the information for grouped features.
}
\details{
The \code{featureGroup} class is the workhorse of \pkg{patRoon}: almost all functionality operate on its instantiated
objects. The class holds all information from grouped features (obtained from \code{\link{features}}). This class
itself is \code{virtual}, hence, objects are not created directly from it. Instead, 'feature groupers' such as
\code{\link{groupFeaturesXCMS}} return a \code{featureGroups} derived object after performing the actual grouping of
features across analyses.
}
\section{Methods (by generic)}{
\itemize{
\item \code{names(featureGroups)}: Obtain feature group names.

\item \code{analyses(featureGroups)}: returns a \code{character} vector with the names of the
analyses for which data is present in this object.

\item \code{replicateGroups(featureGroups)}: returns a \code{character} vector with the names of the
replicate groups for which data is present in this object.

\item \code{groupNames(featureGroups)}: Same as \code{names}. Provided for consistency to other classes.

\item \code{length(featureGroups)}: Obtain number of feature groups.

\item \code{show(featureGroups)}: Shows summary information for this object.

\item \code{groupTable(featureGroups)}: Accessor for \code{groups} slot.

\item \code{analysisInfo(featureGroups)}: Obtain analysisInfo (see analysisInfo slot in \code{\link{features}}).

\item \code{groupInfo(featureGroups)}: Accessor for \code{groupInfo} slot.

\item \code{featureTable(featureGroups)}: Obtain feature information (see \code{\link{features}}).

\item \code{getFeatures(featureGroups)}: Accessor for \code{features} slot.

\item \code{groupFeatIndex(featureGroups)}: Accessor for \code{ftindex} slot.

\item \code{groupQualities(featureGroups)}: Accessor for \code{groupQualities} slot.

\item \code{groupScores(featureGroups)}: Accessor for \code{groupScores} slot.

\item \code{annotations(featureGroups)}: Accessor for \code{annotations} slot.

\item \code{internalStandards(featureGroups)}: Accessor for \code{ISTDs} slot.

\item \code{internalStandardAssignments(featureGroups)}: Accessor for \code{ISTDAssignments} slot.

\item \code{adducts(featureGroups)}: Returns a named \code{character} with adduct annotations assigned to each feature group (if
available).

\item \code{adducts(featureGroups) <- value}: Sets adduct annotations for feature groups.

\item \code{concentrations(featureGroups)}: Accessor for \code{concentrations} slot.

\item \code{toxicities(featureGroups)}: Accessor for \code{toxicities} slot.

\item \code{x[i}: Subset on analyses/feature groups.

\item \code{x[[i}: Extract intensity values.

\item \code{$}: Extract intensity values for a feature group.

\item \code{delete(featureGroups)}: Completely deletes specified feature groups.

\item \code{export(featureGroups)}: Exports feature groups to a \file{.csv} file that is readable to Bruker ProfileAnalysis (a
'bucket table'), Bruker TASQ (an analyte database) or that is suitable as input for the \verb{Targeted peak
detection} functionality of \href{http://mzmine.github.io/}{MZmine}.

\item \code{as.data.table(featureGroups)}: Obtain a summary table (a \code{\link{data.table}}) with retention, \emph{m/z}, intensity
and optionally other feature data.

\item \code{unique(featureGroups)}: Obtain a subset with unique feature groups
present in one or more specified replicate group(s).

\item \code{overlap(featureGroups)}: Obtain a subset with feature groups that overlap
between a set of specified replicate group(s).

\item \code{calculatePeakQualities(featureGroups)}: Calculates peak and group qualities for all features and feature groups. The peak qualities
(and scores) are calculated with the \link[=calculatePeakQualities,features-method]{features method of this
function}, and subsequently averaged per feature group. Then, \pkg{MetaClean} is used to calculate the
\verb{Elution Shift} and \verb{Retention Time Consistency} group quality metrics (see the \pkg{MetaClean}
publication cited below for more details). Similarly to the \code{\link{features}} method, these metrics are scored
by normalizing qualities among all groups and scaling them from \samp{0} (worst) to \samp{1} (best). The
\verb{totalScore} for each group is then calculated as the weighted sum from all feature (group) scores. The
\code{\link{getMCTrainData}} and \code{\link{predictCheckFeaturesSession}} functions can be used to train and apply
Pass/Fail ML models from \pkg{MetaClean}.

\item \code{selectIons(featureGroups)}: uses \link[=generateComponents]{componentization} results to select feature groups with
preferred adduct ion and/or isotope annotation. Typically, this means that only feature groups are kept if they are
(de-)protonated adducts and are monoisotopic. The adduct annotation assignments for the selected feature groups are
copied from the components to the \code{annotations} slot. If the adduct for a feature group is unknown, its
annotation is defaulted to the 'preferred' adduct, and hence, the feature group will never be removed. Furthermore,
if a component does not contain an annotation with the preferred adduct, the most intense feature group is selected
instead. Similarly, if no isotope annotation is available, the feature group is assumed to be monoisotopic and thus
not removed. An important advantage of \code{selectIons} is that it may considerably simplify your dataset.
Furthermore, the adduct assignments allow formula/compound annotation steps later in the workflow to improve their
annotation accuracy. On the other hand, it is important the componentization results are reliable. Hence, it is
highly recommended that, prior to calling \code{selectIons}, the settings to \code{\link{generateComponents}} are
optimized and its results are reviewed with \code{\link{checkComponents}}. Finally, the \code{adducts<-} method can
be used to manually correct adduct assignments afterwards if necessary.

\item \code{normInts(featureGroups)}: Provides various methods to normalizes feature intensities for each sample analysis or of
all features within a feature group. See the \verb{Feature intensity normalization} section below.

\item \code{getTICs(featureGroups)}: Obtain the total ion chromatogram/s (TICs) of the analyses.

\item \code{getBPCs(featureGroups)}: Obtain the base peak chromatogram/s (BPCs) of the analyses.

\item \code{plotTICs(featureGroups)}: Plots the total ion chromatogram/s (TICs) of the analyses.

\item \code{plotBPCs(featureGroups)}: Plots the base peak chromatogram/s (BPCs) of the analyses.

}}
\section{Slots}{

\describe{
\item{\code{groups}}{Matrix (\code{\link{data.table}}) with intensities for each feature group (columns) per analysis (rows).
Access with \code{groups} method.}

\item{\code{analysisInfo,features}}{\link[=analysis-information]{Analysis info} and \code{\link{features}} class associated
with this object. Access with \code{analysisInfo} and \code{featureTable} methods, respectively.}

\item{\code{groupInfo}}{\code{data.frame} with retention time (\code{rts} column, in seconds) and \emph{m/z} (\code{mzs}
column) for each feature group. Access with \code{groupInfo} method.}

\item{\code{ftindex}}{Matrix (\code{\link{data.table}}) with feature indices for each feature group (columns) per analysis
(rows). Each index corresponds to the row within the feature table of the analysis (see
\code{\link{featureTable}}).}

\item{\code{groupQualities,groupScores}}{A \code{\link{data.table}} with qualities/scores for each feature group (see the
\code{calculatePeakQualities} method).}

\item{\code{annotations}}{A \code{\link{data.table}} with adduct annotations for each group (see the \code{selectIons}
method).}

\item{\code{ISTDs}}{A \code{data.table} with screening results for internal standards (filled in by the \code{normInts}
method).}

\item{\code{ISTDAssignments}}{A \code{list}, where each item is named by a feature group and consists of a vector with
feature group names of the internal standards assigned to it (filled in by the \code{normInts} method).}

\item{\code{concentrations,toxicities}}{A \code{data.table} with predicted concentrations/toxicities for each feature group.
Assigned by the \code{\link{calculateConcs}}/\code{\link{calculateTox}} methods. Use the
\code{concentratrions}/\code{toxicities} methods for access.}

\item{\code{groupAlgo,groupArgs,groupVerbose}}{\setsWF Grouping parameters that were used when this object was created. Used
by \code{adducts<-} and \code{selectIons} when these methods perform a re-grouping of features.}

\item{\code{annotations,ISTDAssignments}}{\setsWF As the \code{featureGroups} slots, but contains the data per set.}

\item{\code{annotationsChanged}}{Set internally by \code{adducts()<-} and applied as soon as \code{reGroup=TRUE}.}
}}

\section{S4 class hierarchy}{
 \itemize{   \item{\code{\link{workflowStep}}}   \itemize{     \item{\strong{\code{\link{featureGroups}}}}     \itemize{       \item{\code{\link{featureGroupsSet}}}       \itemize{         \item{\code{\link{featureGroupsScreeningSet}}}       }       \item{\code{\link{featureGroupsUnset}}}       \item{\code{\link{featureGroupsScreening}}}       \itemize{         \item{\code{\link{featureGroupsSetScreeningUnset}}}       }       \item{\code{\link{featureGroupsBruker}}}       \item{\code{\link{featureGroupsConsensus}}}       \item{\code{\link{featureGroupsEnviMass}}}       \item{\code{\link{featureGroupsKPIC2}}}       \item{\code{\link{featureGroupsOpenMS}}}       \item{\code{\link{featureGroupsSIRIUS}}}       \item{\code{\link{featureGroupsBrukerTASQ}}}       \item{\code{\link{featureGroupsXCMS}}}       \item{\code{\link{featureGroupsXCMS3}}}     }   } }
}

\section{Feature intensity normalization}{
 The \code{normInts} method performs normalization of feature intensities
  (and areas). These values are amended in the \code{features} slot, while the original intensities/areas are kept.
  To use the normalized intensities set \code{normalized=TRUE} to methods such as \code{\link{plotInt}},
  \code{\link{generateComponentsIntClust}} and \code{as.data.table}. Please see the \code{normalized} argument
  documentation for these methods for more details.

  The \code{normInts} method supports several methods to normalize intensities/areas of features within the same
  analysis. Most methods are influenced by the \emph{normalization concentration} (\code{norm_conc} in the
  \link[=analysis-information]{analysis information}) set for each sample analysis. For \code{NA} or zero values the
  output will be zero. If the \code{norm_conc} is completely absent from the analysis information, the normalization
  concentration is defaulted to one.

  The different normalization methods are:

  \enumerate{

  \item \code{featNorm="istd"} Uses \emph{internal standards} (IS) for normalization. The IS are screened internally
  by the \code{\link{screenSuspects}} function. Hence, the IS specified by the \code{standards} argument should
  follow the format of a \link[=suspect-screening]{suspect list}. Note that labelled elements in IS formulae should
  be specified with the \CRANpkg{rcdk} format, \emph{e.g.} \code{"[13]C"} for 13C, \code{"[2]H"} for a deuterium etc.
  Example IS lists are provided with the \pkg{patRoonData} package.

  The assignment of IS to features is automatically performed, using the following criteria: \enumerate{

  \item Only analyses are considered with a defined normalization concentration.

  \item The IS must be detected in all of the analyses in which the feature was detected.

  \item The retention time and \emph{m/z} are reasonably close (\code{ISTDRTWindow}/\code{ISTDMZWindow} arguments).
  However, additional IS candidates outside these windows will be chosen if the number of candidates is less than the
  \code{minISTDs} argument. In this case the next close(st) candidate(s) will be chosen.

  }

  Normalization of features within the same feature group always occur with the same IS. If multiple IS are assigned
  to a feature then normalization occurs with the combined intensity (area), which is calculated with the function
  defined by the \code{normFunc} argument. The (combined) IS intensity is then normalized by the normalization
  concentration, and finally used for feature normalization.

  \item \code{featNorm="tic"} Uses the Total Ion Current (TIC) to normalize intensities. The TIC is calculated by
  combining all intensities with the function defined by the \code{normFunc} argument. For this reason, you may need
  to take care to perform normalization before \emph{e.g.} suspect screening or other prioritization techniques. The
  TIC normalized intensities are finally divided by the normalization concentration.

  \item \code{featNorm="conc"} Simply divides all intensities (areas) with the normalization concentration defined
  for the sample.

  \item \code{featNorm="none"} Performs no normalization. The raw intensity values are simply copied. This is mainly
  useful if you only want to do group normalization (described below).

  }

  The meaning of the normalization concentration differs for each method: for \code{"istd"} it resembles the IS
  concentration of a sample analysis, whereas for \code{"tic"} and \code{"conc"} it is used to normalize different
  sample amounts (\emph{e.g.} injection volume).

  If \code{groupNorm=TRUE} then feature intensities (areas) will be normalized by the combined values for its feature
  group (again, combination occurs with \code{normFunc}). This \emph{group normalization} always occurs \emph{after}
  aforementioned normalization methods. Group normalization was the only method with \pkg{patRoon} \samp{<2.1}, and
  still occurs automatically if \code{normInts} was not called when a method is executed that requests normalized
  data.
}

\section{Sets workflows}{
 \setsWFClass{featureGroupsSet}{featureGroups}

  \setsWFNewMethodsFeat{featureGroupsUnset}{The adduct annotations for the selected set are used to convert all
  feature (group) masses to ionic \emph{m/z} values. The annotations persist in the converted object. }

  \setsWFChangedMethods{

  \item \code{adducts}, \code{adducts<-} require the \code{set} argument. The order of the data that is
  returned/changed follows that of the \code{annotations} slot. Furthermore, \code{adducts<-} will perform a
  re-grouping of features when its \code{reGroup} parameter is set to \code{TRUE}. The implications for this are
  discussed below. Note that no adducts are changed \emph{until} \code{reGroup=TRUE}.

  \item the subset operator (\code{[}) has specific arguments to choose (feature presence in) sets. See the argument
  descriptions.

  \item \code{as.data.table}: normalization of intensities is performed per set.

  \item \code{export} Only allows to export data from one set. The \code{unset} method is used prior to exporting the
  data.

  \item \code{overlap} and \code{unique} allow to handle data per set. See the \code{sets} argument description.

  \item \code{selectIons} Will perform a re-grouping of features. The implications of this are discussed below.
  
  \item \code{normInts} Performs normalization for each set \emph{independently}.

  }

  A re-grouping of features occurs if \code{selectIons} is called or \code{adducts<-} is used with
  \code{reGroup=TRUE}. Afterwards, it is very likely that feature group names are changed. Since data generated later
  in the workflow (\emph{e.g.} annotation steps) rely on feature group names, these objects are \strong{not valid}
  anymore, and \strong{must} be re-generated.
}

\references{
\insertRef{Chetnik2020}{patRoon}
}
\seealso{
\code{\link{groupFeatures}} for generating feature groups, \link{feature-filtering} and
  \link{feature-plotting} for more advanced \code{featureGroups} methods.
}
\author{
Ricardo Cunha, \email{cunha@iuta.de}
}
