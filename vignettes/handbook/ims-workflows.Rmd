# Ion mobility spectrometry (IMS-HRMS) workflows

## Introduction

This chapter describes workflows to process data from Ion Mobility Spectrometry coupled to high resolution mass spectrometry (IMS-HRMS) instruments in `patRoon`. These are simply referred to as _IMS workflows_.

IMS is increasingly used to improve non-target analysis, and has the potential to improve separation of isomeric and isobaric compounds, clean up HRMS data and use the collision cross section (CCS) to improve identification of compounds. `patRoon 3.0` adds IMS support throughout the complete workflow and data processing functionality to take advantage of the additional information provided by IMS.

In `patRoon` three types of IMS workflows can be distinguished:

1. **LC-MS workflows with IMS data**: These workflows are like regular (non-IMS) workflows, but work with IMS data.
2. **Direct mobility assignment**: Feature mobilities are assigned directly during feature detection.
3. **Post mobility assignment**: Feature mobilities are assigned after finding and grouping features.

The following sections further detail each of these workflows, including the required data and the steps involved.

> **_NOTE_** IMS workflows are considerably more computationally demanding, as the raw IMS data typically contain several orders of magnitude more mass spectra. This is especially apparent during feature detection, but also subsequent steps such as creation of chromatograms and spectra will take up more time and RAM. The direct mobility assignment workflows are generally most demanding.

### LC-MS workflows with IMS data

In this workflow the raw IMS data is 'collapsed' and is converted in such a way it looks like 'regular' LC-MS data. This is achieved by summing up the mass spectra in each IMS frame and subsequently replacing the IMS frames by the combined spectra. The workflow then proceeds as a regular LC-MS workflow. Hence, this type of workflow does not bring any of the benefits of IMS data, but allows full compatibility with software tools that do not support IMS data. Furthermore, this type of workflow is much less computationally intensive, which makes it suitable for e.g. initial exploration of data.

### Direct mobility assignment {#directIMS}

This workflow relies on a feature detection algorithm that separates features by ion mobility and assigns the feature mobilities directly during feature detection. In `patRoon` this is currently only supported by the `piek` algorithm or by [importing feature data from other algorithms]. None of the feature grouping algorithms currently interfaced by `patRoon` support IMS data. To circumvent this, features with close mobilities are first clustered and then any of the non-IMS algorithms is used to perform sample analysis grouping with each cluster. The grouping results for each cluster are then combined to obtain the final feature groups. Most of the remaining workflow is the same as non-IMS workflows. However, it typically adds steps to calculate CCS values for features and matches these with (predicted) CCS values of suspects and/or compound annotation candidates. Furthermore, the IMS data is internally used to cleanup extracted ion chromatograms and mass spectra, which can improve their visualization and quality of feature annotation.

### Post mobility assignment {#postIMS}

Post mobility assignment workflows can be considered as a hybrid approach to the two previous workflow types: the workflow starts with feature detection and grouping as in a regular LC-MS workflow, followed by assigning IMS data to features and then proceeding much like the direct mobility assignment workflow.

The mobility assignment consists of the following steps:

1. Feature detection and grouping is performed with classical algorithms like regular LC-MS workflows.
2. Extracted ion mobilograms are generated for each feature and automatic peak detection is used to detect mobilities.
3. Each of the detected mobilities for a feature are used to generate a new set of _mobility features_. These features inherit their properties from the original features, which are referred to as _IMS parents_. A link is formed between the mobility features and the IMS parent.
4. The mobility feature data such as retention time and range is updated from mobility filtered extracted ion chromatograms. Any features that could not be detected from the filtered data are removed.
5. The feature groups are updated with IMS data and similar links between _mobility feature groups_ and _IMS parents_ are formed.

All these steps are automatically performed by the `assignMobilities()` method function that will be discussed later.

An advantage of post mobility workflows is the compatibility with any of the feature detection and grouping algorithms supported in `patRoon`. In addition, post assignment is often less computationally intensive than direct mobility assignment workflows. Furthermore, the links between mobility features and IMS parents facilitate the recognition of possible protomers (i.e. redundant features of a same compound with the same retention time and _m/z_ but different mobility) and enables the use of [sets workflows](#setsWorkflow). Finally, post mobility assignment workflows can selectively fallback to 'regular' LC-MS feature data from the IMS parents in steps where this makes more sense, this will be discussed later. Potential disadvantages of post mobility assignment workflows are the reliance on raw data that is with and without IMS dimesnion, and the mobility assignment typically relies on two steps of peak detection (steps 2 and 4) which may fail with e.g. low intensity data. Nevertheless, this type of workflow is usually recommended for most IMS data processing projects.

### Summary

The following table summarizes the differences between the three IMS workflows:

|                               | LC-MS with IMS data | Direct mobility assignment | Post mobility assignment
------------------------------- | ------------------- | -------------------------- | --------------------------
Raw data requirements^1^        | IMS collapsed       | Raw IMS data               | IMS and IMS collapsed raw data
Feature detection               | Regular non-IMS     | Utilizes IMS separation    | Regular non-IMS
Feature grouping                | Regular non-IMS     | Regular non-IMS with IMS clustering | Regular non-IMS
Feature mobility assignment     | No                  | During feature detection   | After feature grouping
Feature CCS assignment          | No                  | Yes                        | Yes
Mobility/IMS parent links       | No                  | No                         | Yes
Suspect & compound CCS matching | No                  | Yes                        | Yes
HRMS cleanup                    | No                  | Yes                        | Yes
non-IMS feature fallback        | -                   | No                         | Yes
Supports [sets workflows](#setsWorkflow) | Yes        | No                         | Yes

Notes:

1. If the `piek` feature detection algorithm is used then (only) IMS raw data may suffice, see [more info here].

## Performing IMS workflows

### Raw data

The [data conversion and pre-treatment](#pre-treat) section already discussed how raw data can be converted to make it suitable for processing. For the workflows that require raw data that has IMS data (see the Table of the previous section) there are two options:

1. Use the raw instrument directly. This is currently only supported for Bruker TIMS data, see [details here].
2. Convert the data to the `ims` type in the `mzML` file format, e.g. by using `convertMSFiles()` ([explained here](#pre-treat)).

If IMS collapsed data is needed (see the Table of the previous section) then raw data of the type `raw` or `ims` should be converted to the type `centroid`.

The [data conversion and pre-treatment](#pre-treat) section includes some examples on how to do these conversion steps.

### Feature detection and grouping in direct mobility assignment workflows

In direct IMS workflows the feature detection needs to be aware of the IMS dimension. In `patRoon` this is currently only supported by the `piek` algorithm. Alternatively, feature data from another IMS aware feature detection [can also be imported].

The `piek` algorithm was already [discussed before]. In IMS workflows the `methodIMS` parameter should additionally be configured, and influences the formation of extracted ion chromatograms (EICs) similarly as the `methodMZ` parameter. Like `methodMZ`, it should be set to `"bins"`, `"suspects"` or `"ms2"`. The following combinations of `methodMZ` and `methodIMS` are supported:

`methodMZ`   | `methodIMS`  | EIC formation
------------ | ------------ | -----------------------------------------------------------------------
`"bins"`     | `"bins"`     | from two dimensional _m/z_ and ion mobility bins.
`"suspects"` | `"suspects"` | from HRMS and IMS data in a suspect list.
`"suspects"` | `"bins"`     | from suspect HRMS data that is expanded with IMS bins.
`"ms2"`      | `"ms2"`      | from the HRMS and IMS data of the precursors detected in Bruker DDA-PASEF MS2 experiments.
`"ms2"`      | `"bins"`     | from the HRMS data of the precursors detected in Bruker DDA-PASEF MS2 experiments that is expanded with IMS bins.

Some examples are given below:

```{r exDirectMob, eval=FALSE}
# comprehensive feature detection from 2 dimensional bins
fParams <- getPiekParams(methodMZ = "bins", methodIMS = "bins", mzRange = c(100, 300), mobRange = c(0.5, 1.5))
pParams <- getDefPeakParams("chrom", "piek")
fList <- findFeatures(anaInfo, "piek", featParams = fParams, peakParams = pParams)

# use PASEF MS2 data to detect features
fParams <- getPiekParams(methodMZ = "ms2", methodIMS = "ms2", minTIC = 1000)
fList <- findFeatures(anaInfo, "piek", featParams = fParams, peakParams = pParams)

# combine suspect data with IMS bins (e.g. if suspect list doesn't contain IMS data)
fParams <- getPiekParams(methodMZ = "suspects", methodIMS = "bins", mobRange = c(0.5, 1.5))
fList <- findFeatures(anaInfo, "piek", featParams = fParams, peakParams = pParams,
                      suspects = suspList, adduct = "[M+H]+")
```

> **_NOTE_** when both `methodMZ` and `methodIMS` are set to `"bins"` then peak detection will need to cover a very large number of EICs, which can be be quite computationally intensive. Tweaking the EIC filtering parameters can improve the situation, see `?getPiekParams` for more details.

The grouping of features is performed with `groupFeatures()` as in non-IMS workflows. This automatically perform the necessary IMS clustering and grouping steps ([discussed here](#directIMS)).

### Post mobility assignment with `assignMobilities()` {#assignMobFeat}

The `assignMobilities()` method function is used to assign mobilities to features and feature groups in post mobility assignment workflows. It is executed after executing `groupFeatures()`, with often some intermediate steps (e.g. filtering, componentization) steps in-between (discussed later). A single call to `assignMobilities()` will perform all [the steps that were introduced before](#postIMS), and includes some additional functionality for suspect screening workflows ([discussed later]). The most important function arguments are:

Argument                 | Description
------------------------ | ------------------------------------------------
`mobPeaksParams`, `chromPeaksParams` | Parameters for the peak detection in mobilograms and chromatograms, respectively. See `getDefPeakParams()` for more details.
`EIMParams`, `EICParams` | Parameters for the extraction of ion mobilograms (EIMs) and chromatograms (EICs), respectively. See `getDefEIMParams()` and `getDefEICParams()` for more details.
`fallbackEIC`            | Set to `TRUE` to use the raw EIC data to update properties of mobility features, in case peak detection in mobility filtered EICs failed ([steps 3-4](#postIMS)).

Some examples of how to use `assignMobilities()` are given below:

```{r exPostMob, eval=FALSE}
fGroups <- assignMobilities(fGroups, mobPeaksParams = getDefPeakParams("bruker_ims", "piek"),
                            chromPeaksParams = getDefPeakParams("chrom", "piek"))

# customized peak detection
fGroups <- assignMobilities(fGroups, mobPeaksParams = getDefPeakParams("agilent_ims", "xcms3", peakwidth = c(0.2, 3)),
                            chromPeaksParams = getDefPeakParams("chrom", "openms", gaussWidth = 20))
```

### Suspect screening

[Suspect screening](#suspscr) in IMS workflows is mostly the same as in non-IMS workflows. However, the suspect list can be extended with IMS properties to improve suspect matching, and performing the screening step is slightly different.

#### Suspect list

The suspect list can contain the following additional columns (all optional):

* `mobility`: The mobility of the suspect.
* `CCS`: The collision cross section (CCS) of the suspect.
* `mobility_<adduct>`, `CCS_<adduct>`: The mobility and CCS of the suspect for a specific adduct. The `<adduct>` should be replaced with the adduct name, e.g. `mobility_[H+Na]+` or `CCS_[M-H]-`.

Multiple suspect reference values can specified in each of the columns by separating them with a semicolon (`;`). If data for both the adduct and non-adduct specific columns is available (and not `NA`), then the latter gets precedence. It is recommended to include the adduct specific data whenever possible. During the suspect screening step to correct data is automatically chosen based on the adduct assigned to the feature (or assigned to the `adduct` function argument).

#### Prediction of mobility and CCS data

The `assignMobilities()` function that [was discussed before](#assignMobFeat) also has a method specifically for suspect lists. It can be used for the prediction (or library matching) of IMS data for suspects and convert CCS values to mobilities (or vice versa). The common function arguments include:

Function argument | Description
----------------- | ---------------------------------------------------------------
`from`            | Specifies from where IMS data is added. See below for more details.
`adducts`         | Specifies for which adducts IMS data is added or converted. A `character` vector with multiple values is allowed. Include `NA` to also consider the usage of non-adduct specific data. Any adducts specified in the suspect list (`adduct` column) are always considered.
`CCSParams`       | Parameters for the mobility <--> CCS conversions. See the previous section for more details.
`overwrite`       | Set to `TRUE` to overwrite any existing IMS data in the suspect list.

The following options exist for the `from` function argument:

* `from=NULL` (default): No IMS data is added.
* `from="pubchemlite"`: IMS data is matched from the [PubChemLite database with CCS][PCLiteCCS-dl] data. See the [Installation chapter](#Installation) for details on how to install the database.
* `from="c3sdb"`: Uses [C3SDB] to predict CCS values for suspects. See the [Installation chapter](#Installation) for installation details.
* a `data.table` or `data.frame`: A custom library with IMS data.

Some examples:

```{r assignMobSusps, eval=FALSE}
# adds CCS values from PubChemLite and converts them to mobilities
suspList <- assignMobilities(suspList, from = "pubchemlite", adducts = c("[M+H]+", "[M+Na]+", "[M+H]-"),
                             CCSParams = getCCSParams("bruker"))

# adds (non-adduct specific) CCS values from custom library
IMSLib <- data.frame(
    name = c("Caffeine", "Acetaminophen"), # name column is not mandatory
    InChIKey = c("RYYVLZVUVIJVGH-UHFFFAOYSA-N", "RZVAJINKPMORJF-UHFFFAOYSA-N"),
    CCS = c(150, 160)
))
suspList <- assignMobilities(suspList, from = IMSLib, adducts = NA)
```

#### Performing suspect screening

The `screenSuspects()` method function [introduced before](#suspscr) is also used to perform the suspect screening in IMS workflows. The `IMSMatchParams` argument configures how IMS data is used to match suspects and features. See `?getIMSMatchParams` and the examples below for more details.

In post mobility assignment workflows, it is possible to perform the suspect screening _before_ `assignMobilities()` is executed to assign the feature mobilities. In this case the `IMSMatchParams` argument can also be passed to `assignMobilities()` to filter out any suspect hits with deviating IMS data after feature mobilities have been assigned. This may be useful to e.g. first prioritize features with suspect screening and other steps before assigning mobilities to the remaining features.

Some examples are shown below:

```{r screenIMS,eval=FALSE}
# suspList is a suspect list with CCS and mobility data (see previous subsections)

# screen with default CCS matching parameters
fGroupsScr <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+",
                             IMSMatchParams = getIMSMatchParams("CCS"))

# match suspects on mobility with a +/- 0.1 tolerance
fGroupsScr <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+",
                             IMSMatchParams = getIMSMatchParams("mobility", window = 0.1))

# match suspects on CCS with a +/- 6% tolerance
fGroupsScr <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+",
                             IMSMatchParams = getIMSMatchParams("CCS", window = 0.06, relative = TRUE))

# post mobility assignment workflow with prior suspect screening
# regular non-IMS suspect screening
fGroupsScr <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+", onlyHits = TRUE)
# ... do other things such as more feature prioritization
# ... and assign mobilities to the remaining features, match already screened suspects by CCS
fGroupsScr <- assignMobilities(fGroupsScr, mobPeaksParams = getDefPeakParams("bruker_ims", "piek"),
                               chromPeaksParams = getDefPeakParams("chrom", "piek"),
                               IMSMatchParams = getIMSMatchParams("CCS"))
```
