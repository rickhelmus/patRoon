# Ion mobility spectrometry (IMS-HRMS) workflows

## Introduction {#IMSWorkflow}

This chapter describes workflows to process data from Ion Mobility Spectrometry coupled to high resolution mass spectrometry (IMS-HRMS) instruments in `patRoon`. These are simply referred to as _IMS workflows_.

IMS is increasingly used to improve non-target analysis, and has the potential to improve separation of isomeric and isobaric compounds, clean up HRMS data and use the collision cross section (CCS) to improve identification of compounds. `patRoon 3.0` adds IMS support throughout the complete workflow and data processing functionality to take advantage of the additional information provided by IMS.

In `patRoon` three types of IMS workflows can be distinguished:

1. **LC-MS workflows with IMS data**: These workflows are like regular (non-IMS) workflows, but work with IMS data.
2. **Direct mobility assignment**: Feature mobilities are assigned directly during feature detection.
3. **Post mobility assignment**: Feature mobilities are assigned after finding and grouping features.

The following sections further detail each of these workflows, including the required data and the steps involved.

> **_NOTE_** IMS workflows are considerably more computationally demanding, as the raw IMS data typically contain several orders of magnitude more mass spectra. This is especially apparent during feature detection, but also subsequent steps such as creation of chromatograms and spectra will take up more time and RAM. The direct mobility assignment workflows are generally most demanding.

> **_NOTE_** While IMS workflows are largely the same as non-IMS workflows, there are some important considerations (outlined in this chapter). It is highly recommended to experiment with the [newProject tool](#newProject) and study the [example workflow](#exIMSWorkflow) to get a feeling of how IMS workflows work.

### LC-MS workflows with IMS data

In this workflow the raw IMS data is 'collapsed' and is converted in such a way it looks like 'regular' LC-MS data. This is achieved by summing up the mass spectra in each IMS frame and subsequently replacing the IMS frames by the combined spectra. The workflow then proceeds as a regular LC-MS workflow. Hence, this type of workflow does not bring any of the benefits of IMS data, but allows full compatibility with software tools that do not support IMS data. Furthermore, this type of workflow is much less computationally intensive, which makes it suitable for e.g. initial exploration of data.

### Direct mobility assignment {#directIMS}

This workflow relies on a feature detection algorithm that separates features by ion mobility and assigns the feature mobilities directly during feature detection. In `patRoon` this is currently only supported by the `piek` algorithm or by [importing feature data from other algorithms]. None of the feature grouping algorithms currently interfaced by `patRoon` support IMS data. To circumvent this, features with close mobilities are first clustered and then any of the non-IMS algorithms is used to perform sample analysis grouping with each cluster. The grouping results for each cluster are then combined to obtain the final feature groups. Most of the remaining workflow is the same as non-IMS workflows. However, it typically adds steps to calculate CCS values for features and matches these with (predicted) CCS values of suspects and/or compound annotation candidates. Furthermore, the IMS data is internally used to cleanup extracted ion chromatograms and mass spectra, which can improve their visualization and quality of feature annotation.

### Post mobility assignment {#postIMS}

Post mobility assignment workflows can be considered as a hybrid approach to the two previous workflow types: the workflow starts with feature detection and grouping as in a regular LC-MS workflow, followed by assigning IMS data to features and then proceeding much like the direct mobility assignment workflow.

The mobility assignment consists of the following steps:

1. Feature detection and grouping is performed with classical algorithms like regular LC-MS workflows.
2. Extracted ion mobilograms are generated for each feature and automatic peak detection is used to detect mobilities.
3. Each of the detected mobilities for a feature are used to generate a new set of _mobility features_. These features inherit their properties from the original features, which are referred to as _IMS parents_. A link is formed between the mobility features and the IMS parent.
4. The mobility feature data such as retention time and intensities is updated from mobility filtered extracted ion chromatograms. Any features that could not be detected from the filtered data are removed.
5. The feature groups are updated with IMS data and similar links between _mobility feature groups_ and _IMS parents_ are formed.

All these steps are automatically performed by the `assignMobilities()` method function that will be discussed later.

An advantage of post mobility workflows is the compatibility with any of the feature detection and grouping algorithms supported in `patRoon`. In addition, post assignment is often less computationally intensive than direct mobility assignment workflows. Furthermore, the links between mobility features and IMS parents facilitate the recognition of possible protomers (i.e. redundant features of a same compound with the same retention time and _m/z_ but different mobility) and enables the use of [sets workflows](#setsWorkflow). Finally, post mobility assignment workflows can selectively fallback to 'regular' LC-MS feature data from the IMS parents in steps where this makes more sense, this will be discussed later. Potential disadvantages of post mobility assignment workflows are the reliance on raw data that is with and without IMS dimesnion, and the mobility assignment typically relies on two steps of peak detection (steps 2 and 4) which may fail with e.g. low intensity data. Nevertheless, this type of workflow is usually recommended for most IMS data processing projects.

### Summary

The following table summarizes the differences between the three IMS workflows (some of these are introduced later in this chapter):

|                               | LC-MS with IMS data | Direct mobility assignment | Post mobility assignment
------------------------------- | ------------------- | -------------------------- | --------------------------
Raw data requirements^1^        | IMS collapsed       | Raw IMS data               | IMS and IMS collapsed raw data
Feature detection               | Regular non-IMS     | Utilizes IMS separation    | Regular non-IMS
Feature grouping                | Regular non-IMS     | Regular non-IMS with IMS clustering | Regular non-IMS
Feature mobility assignment     | No                  | During feature detection   | After feature grouping
Feature CCS assignment          | No                  | Yes                        | Yes
Mobility/IMS parent links       | No                  | No                         | Yes
Suspect & compound CCS matching | No                  | Yes                        | Yes
HRMS cleanup                    | No                  | Yes                        | Yes
non-IMS feature fallback        | -                   | No                         | Yes
Supports [sets workflows](#setsWorkflow)^2^ | Yes     | Limited                    | Limited

Notes:

1. If the `piek` feature detection algorithm is used then (only) IMS raw data may suffice, see [more info here].
2. Discussed further [here](#IMSSetsWorkflow) 

## Performing IMS workflows

### Raw data

The [data conversion and pre-treatment](#pre-treat) section already discussed how raw data can be converted to make it suitable for processing. For the workflows that require raw data that has IMS data (see the Table of the previous section) there are two options:

1. Use the raw instrument directly. This is currently only supported for Bruker TIMS data, see [details here].
2. Convert the data to the `ims` type in the `mzML` file format, e.g. by using `convertMSFiles()` ([explained here](#pre-treat)).

If IMS collapsed data is needed (see the Table of the previous section) then raw data of the type `raw` or `ims` should be converted to the type `centroid`.

The [data conversion and pre-treatment](#pre-treat) section includes some examples on how to do these conversion steps.

### Feature detection and grouping in direct mobility assignment workflows

In direct IMS workflows the feature detection needs to be aware of the IMS dimension. In `patRoon` this is currently only supported by the `piek` algorithm. Alternatively, feature data from another IMS aware feature detection [can also be imported].

The `piek` algorithm was already [discussed before]. In IMS workflows the `methodIMS` parameter should additionally be configured, and influences the formation of extracted ion chromatograms (EICs) similarly as the `methodMZ` parameter. Like `methodMZ`, it should be set to `"bins"`, `"suspects"` or `"ms2"`. The following combinations of `methodMZ` and `methodIMS` are supported:

`methodMZ`   | `methodIMS`  | EIC formation
------------ | ------------ | -----------------------------------------------------------------------
`"bins"`     | `"bins"`     | from two dimensional _m/z_ and ion mobility bins.
`"suspects"` | `"suspects"` | from HRMS and IMS data in a suspect list.
`"suspects"` | `"bins"`     | from suspect HRMS data that is expanded with IMS bins.
`"ms2"`      | `"ms2"`      | from the HRMS and IMS data of the precursors detected in Bruker DDA-PASEF MS2 experiments.
`"ms2"`      | `"bins"`     | from the HRMS data of the precursors detected in Bruker DDA-PASEF MS2 experiments that is expanded with IMS bins.

Some examples are given below:

```{r exDirectMob, eval=FALSE}
# comprehensive feature detection from 2 dimensional bins
fParams <- getPiekParams(methodMZ = "bins", methodIMS = "bins", mzRange = c(100, 300), mobRange = c(0.5, 1.5))
pParams <- getDefPeakParams("chrom", "piek")
fList <- findFeatures(anaInfo, "piek", featParams = fParams, peakParams = pParams)

# use PASEF MS2 data to detect features
fParams <- getPiekParams(methodMZ = "ms2", methodIMS = "ms2", minTIC = 1000)
fList <- findFeatures(anaInfo, "piek", featParams = fParams, peakParams = pParams)

# combine suspect data with IMS bins (e.g. if suspect list doesn't contain IMS data)
fParams <- getPiekParams(methodMZ = "suspects", methodIMS = "bins", mobRange = c(0.5, 1.5))
fList <- findFeatures(anaInfo, "piek", featParams = fParams, peakParams = pParams,
                      suspects = suspList, adduct = "[M+H]+")
```

> **_NOTE_** when both `methodMZ` and `methodIMS` are set to `"bins"` then peak detection will need to cover a very large number of EICs, which can be be quite computationally intensive. Tweaking the EIC filtering parameters can improve the situation, see `?getPiekParams` for more details.

The grouping of features is performed with `groupFeatures()` as in non-IMS workflows. This automatically performs the necessary IMS clustering and grouping steps ([discussed here](#directIMS)).

### Assigning mobility and CCS values to features {#assignMobFeat}

The `assignMobilities()` method function has two purposes:

1. Assign mobilities to features in a post mobility assignment workflow.
2. Convert mobility to CCS values in both direct and post mobility assignment workflows.

The most important function arguments are:

Argument                 | Description
------------------------ | ------------------------------------------------
`mobPeaksParams`, `chromPeaksParams` | Parameters for the peak detection in mobilograms and chromatograms, respectively. See `getDefPeakParams()` for more details.
`EIMParams`, `EICParams` | Parameters for the extraction of ion mobilograms (EIMs) and chromatograms (EICs), respectively. See `getDefEIMParams()` and `getDefEICParams()` for more details.
`fallbackEIC`            | Set to `TRUE` to use the raw EIC data to update properties of mobility features, in case peak detection fails in mobility filtered EICs ([steps 3-4](#postIMS)).
`fromSuspects`           | _Suspect screening workflows_: Use suspect data for mobility assignment, this is [discussed later](#assignMobFromSusps).
`IMSMatchParams`         | _Suspect screening workflows_: parameters to match IMS data between features and suspects, this is [discussed later](#screenIMS).
`CCSParams`              | Parameters for converting mobility <--> CCS values.

The following subsections further discuss the two purposes of `assignMobilities()` in more detail. More details on `assignMobilities()` are found in the reference manual (`?assignMobilities_feat`).

#### Feature mobility assignment

Mobility assignment (purpose \#1) is only performed if either `mobPeaksParams` or `fromSuspects` is set. The latter is [discussed later](#assignMobFromSusps). The `assignMobilities()` method function is executed after executing `groupFeatures()`, with often some intermediate steps in-between (e.g. filtering, componentization, discussed later in this chapter). A single call to `assignMobilities()` will perform all [the mobility assignment steps that were introduced before](#postIMS). 

Some examples of how to use `assignMobilities()` for mobility assignment are given below:

```{r exPostMob, eval=FALSE}
fGroups <- assignMobilities(fGroups, mobPeaksParams = getDefPeakParams("bruker_ims", "piek"),
                            chromPeaksParams = getDefPeakParams("chrom", "piek"))

# customized peak detection parameters
fGroups <- assignMobilities(fGroups, mobPeaksParams = getDefPeakParams("agilent_ims", "xcms3", peakwidth = c(0.2, 3)),
                            chromPeaksParams = getDefPeakParams("chrom", "openms", gaussWidth = 20))
```

#### Mobility <--> CCS conversion {#mobCCSConv}

Conversion of mobility <--> CCS values (purpose \#2) is performed if the `CCSParams` function argument is set. This argument should be assigned with a `list` that contains the parameters to configure the conversions process. The parameters are instrument specific and the parameter list can be obtained with the `getCCSParams()` function. The most important arguments for `getCCSParams()` are:

Function argument | Description
----------------- | ---------------------------------------------------------------
`method`          | Specifies the conversion method. Valid values are: `"bruker"`, `"mason-schamp_k"` `"mason-schamp_1/k"` or `"agilent"`.
`calibrant`       | Specifies the calibrant file or parameters if `method="agilent"`.

The function currently only supports Bruker TIMS and Agilent IMS data (contributions to Waters data and information are _very welcome!_). For Bruker TIMS instruments, the `method` should be set to `"bruker"` or `"mason-schamp_1/k"`. The former relies on the Bruker TDF-SDK (see the [Installation](#Installation) chapter to install it). The latter doesn't, but may give very minor differences in the results compared to how Bruker software performs its calculations. For Agilent IMS data, the `method` should be set to `"agilent"` and the `calibrant` argument should be set to configure the calibration settings. The value for `calibrant` is either a file path to the `.d` or `‘OverrideImsCal.xml` file that should be used for re-calibration, or a `list` with the elements `massGas`, `TFix` and `beta`. It is recommended to read the reference manual for the `getCCSParams()` function for more details (`?getCCSParams`).

Some examples of how to use `assignMobilities()` for mobility <--> CCS conversion are given below:

```{r exMobCCS, eval=FALSE}
# conversion of Bruker TIMS data using the TDF-SDK
fGroups <- assignMobilities(fGroups, CCSParams = getCCSParams("bruker"))

# conversion of Agilent IMS data
fGroups <- assignMobilities(fGroups, CCSParams = getCCSParams("agilent", calibrant = "path/to/Calibrant.d"))

# combine mobility assignment and CCS conversion into one step
fGroups <- assignMobilities(fGroups, mobPeaksParams = getDefPeakParams("bruker_ims", "piek"),
                            chromPeaksParams = getDefPeakParams("chrom", "piek"),
                            CCSParams = getCCSParams("bruker"))
```

### Suspect screening {#IMSSuspScr}

[Suspect screening](#suspscr) in IMS workflows is mostly the same as in non-IMS workflows. However, the suspect list can be extended with IMS properties to improve suspect matching, and performing the screening step is slightly different.

#### Suspect list

The suspect list can contain the following additional columns (all optional):

* `mobility`: The mobility of the suspect.
* `CCS`: The collision cross section (CCS) of the suspect.
* `mobility_<adduct>`, `CCS_<adduct>`: The mobility and CCS of the suspect for a specific adduct. The `<adduct>` should be replaced with the adduct name, e.g. `mobility_[H+Na]+` or `CCS_[M-H]-`.

Multiple suspect reference values can specified in each of the columns by separating them with a semicolon (`;`). If data for both the adduct and non-adduct specific columns is available (and not `NA`), then the latter gets precedence. It is recommended to include the adduct specific data whenever possible. During the suspect screening step to correct data is automatically chosen based on the adduct assigned to the feature (or assigned to the `adduct` function argument).

#### Prediction of mobility and CCS data {#assignMobSusps}

The `assignMobilities()` function that [was discussed before](#assignMobFeat) also has a method specifically for suspect lists. It can be used for the prediction (or library matching) of IMS data for suspects and convert CCS values to mobilities (or vice versa). The common function arguments include:

Function argument | Description
----------------- | ---------------------------------------------------------------
`from`            | Specifies from where IMS data is added. See below for more details.
`adducts`         | Specifies for which adducts IMS data is added or converted. A `character` vector with multiple values is allowed. Include `NA` to also consider the usage of non-adduct specific data. Any adducts specified in the suspect list (`adduct` column) are always considered.
`CCSParams`       | Parameters for the mobility <--> CCS conversions. See [its previous introduction](#mobCCSConv).
`overwrite`       | Set to `TRUE` to overwrite any existing IMS data in the suspect list.

The following options exist for the `from` function argument:

* `from=NULL` (default): No IMS data is added.
* `from="pubchemlite"`: IMS data is matched from the [PubChemLite database with CCS][PCLiteCCS-dl] data. See the [Installation chapter](#Installation) for details on how to install the database.
* `from="c3sdb"`: Uses [C3SDB] to predict CCS values for suspects. See the [Installation chapter](#Installation) for installation details.
* a `data.table` or `data.frame`: A custom library with IMS data.

Some examples:

```{r assignMobSusps, eval=FALSE}
# adds CCS values from PubChemLite and converts them to mobilities
suspList <- assignMobilities(suspList, from = "pubchemlite", adducts = c("[M+H]+", "[M+Na]+", "[M+H]-"),
                             CCSParams = getCCSParams("bruker"))

# adds (non-adduct specific) CCS values from custom library
IMSLib <- data.frame(
    name = c("Caffeine", "Acetaminophen"), # name column is not mandatory
    InChIKey = c("RYYVLZVUVIJVGH-UHFFFAOYSA-N", "RZVAJINKPMORJF-UHFFFAOYSA-N"),
    CCS = c(150, 160)
))
suspList <- assignMobilities(suspList, from = IMSLib, adducts = NA)
```

#### Performing suspect screening {#screenIMS}

The `screenSuspects()` method function [introduced before](#suspscr) is also used to perform the suspect screening in IMS workflows. The `IMSMatchParams` argument configures how IMS data is used to match suspects and features. See `?getIMSMatchParams` and the examples below for more details.

In post mobility assignment workflows, it is possible to perform the suspect screening _before_ `assignMobilities()` is executed to assign the feature mobilities. In this case the `IMSMatchParams` argument can also be passed to `assignMobilities()` to filter out any suspect hits with deviating IMS data after feature mobilities have been assigned. This may be useful to e.g. first prioritize features with suspect screening and other steps before assigning mobilities to the remaining features.

Some examples are shown below:

```{r screenIMS,eval=FALSE}
# suspList is a suspect list with CCS and mobility data (see previous subsections)

# screen with default CCS matching parameters
fGroupsScr <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+",
                             IMSMatchParams = getIMSMatchParams("CCS"))

# match suspects on mobility with a +/- 0.1 tolerance
fGroupsScr <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+",
                             IMSMatchParams = getIMSMatchParams("mobility", window = 0.1))

# match suspects on CCS with a +/- 6% tolerance
fGroupsScr <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+",
                             IMSMatchParams = getIMSMatchParams("CCS", window = 0.06, relative = TRUE))

# post mobility assignment workflow with prior suspect screening
# regular non-IMS suspect screening
fGroupsScr <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+", onlyHits = TRUE)
# ... do other things such as more feature prioritization
# ... and assign mobilities to the remaining features, match already screened suspects by CCS
fGroupsScr <- assignMobilities(fGroupsScr, mobPeaksParams = getDefPeakParams("bruker_ims", "piek"),
                               chromPeaksParams = getDefPeakParams("chrom", "piek"),
                               IMSMatchParams = getIMSMatchParams("CCS"))
```

#### Assigning feature mobilities from suspect data {#assignMobFromSusps}

In post mobility assignment workflows, the `assignMobilities()` method function can also be used to assign feature mobilities from suspect data by setting the `fromSuspects` argument to `TRUE`. This replaces the mobility assignment step from mobilograms ([step 2](#postIMS)), and copies the assigned reference value for a suspect directly to feature data. If both `fromSuspects` and `mobPeaksParams` are set, then the mobility detection from mobilograms is performed in case of missing suspect data. The `IMSRange` function argument is used to derive the mobility range for the feature. Assigning mobilities from suspect data is only supported if the suspect screening was already performed prior to calling `assignMobilities()`.

Bypassing the need for peak detection for mobility assignment may be advantageous for low intensity features. However, no adjustments are performed for any shifts observed experimentally, hence, the assigned mobility values could be less accurate. Furthermore, the assigned mobility range to the feature may not cover the actual experimental range (i.e. the peak width in a mobilogram). Thus, when intensities are updated for mobility features ([step 4](#postIMS)), these can be superficially low (i.e. partial removal of signal) or high (i.e. inclusion of data of neighboring mobility peaks). With this in mind, this approach is primarily intended for the following scenarios:

1. The mobility for a suspect is accurately known in advance, and no additional peak detection is needed. In this case the `IMSWindow` argument is typically set to a narrow tolerance window.
2. There is no interest for accurate mobility (and CCS) assignment, and IMS data should only be used as a rough filtering step. In this scenario the `IMSWindow` argument is typically set to a relatively large tolerance window.

> **_NOTE_** It is strongly recommended to set `fallBackEICs=FALSE` when using `fromSuspects=TRUE`, as otherwise no actual verification steps for the presence of mobility features are performed.

Below are some example of how to use `assignMobilities()` to assign feature mobilities from suspect data:

```{r assignMobFromSusps, eval=FALSE}
# suspect screening must be performed in advance
# suspList is a suspect list with IMS data (see previous subsections)
fGroups <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+", onlyHits = TRUE)

# scenario #1: assume suspect data is accurate
fGroups <- assignMobilities(fGroups, fromSuspects = TRUE, IMSWindow = 0.01, fallBackEICs = FALSE)

# scenario #2: wide tolerance window, no interest in accurate mobility assignment
# add fallback to mobility detection for suspects with mobility data
# set IMSMatchParams to also filter out suspect hits with deviating mobilities
fGroups <- assignMobilities(fGroups, fromSuspects = TRUE, IMSWindow = 0.1, fallBackEICs = FALSE,
                            mobPeaksParams = getDefPeakParams("bruker_ims", "piek"),
                            IMSMatchParams = getIMSMatchParams("CCS"))
```

For more details see the reference manual (`?assignMobilities_feat`).

### Componentization

The algorithms that use componentization to detect adducts, isotopes, homologous series etc. (e.g. [CAMERA], [cliqueMS] and [nontarget]) currently do not support IMS data. They are not supported in direct mobility assignment workflows. However, in post mobility assignment workflows they can operate on the IMS parents (either before or after calling `assignMobilities()`).

The other componentization algorithms (e.g. intensity clustering and [transformation products](#TPs)) optionally include mobility features and IMS parents during the componentization. This is controlled by the `IMS` function argument to the `generateComponents()` function, and can be set as following:

1. `IMS=FALSE`: Do not consider any mobility features (only supported in post mobility assignment workflows).
2. `IMS=TRUE`: Only consider mobility features and ignore any IMS parents.
3. `IMS="both"`: Consider both mobility features and IMS parents.
4. `IMS="maybe"`: Consider IMS parents if present, and mobility features otherwise. This is the default value.

In the case that mobility features are not considered (i.e. `IMS=FALSE` or `IMS="maybe"`), then the componentization data from the IMS parents is directly copied to the mobility features. This is useful when the componentization results for IMS parents and mobility features are expected to be similar, which is often the case for the algorithms that support the `IMS` argument.

In post mobility assignment workflows, it is possible to perform the componentization prior to calling `assignMobilities()`. In this case the componentization results can be 'expanded' by copying the IMS parent results to the mobility features afterwards. This is performed by the `expandForIMS()` method function:

```{r expandComponIMS, eval=FALSE}
# perform componentization
components <- generateComponents(fGroups, "intclust")
# assign mobilities
fGroups <- assignMobilities(fGroups, mobPeaksParams = getDefPeakParams("bruker_ims", "piek"),
                            chromPeaksParams = getDefPeakParams("chrom", "piek"))
# expand componentization results for mobility features
components <- expandForIMS(components, fGroups)
```

### Annotation

IMS workflows bring several advantages to feature annotation. The `generateMSPeakLists()` function automatically filters MS and MS/MS spectra by the mobility range assigned to the feature, which can considerably improve the quality of peak lists. Furthermore, CCS data can be assigned to compound annotation candidates and used to eliminate unlikely candidates.

> **_NOTE_** In post mobility assignment workflows it is important that the `assignMobilities()` method function is called _prior_ to any feature annotation steps in order to take advantage IMS data during feature annotation.

#### MS peak lists

The `generateMSPeakLists()` function automatically filters MS and MS/MS spectra by mobility data assigned to features, and is therefore used similarly like non-IMS workflows. The function supports Bruker PASEF experiments, and can therefore assign _m/z_ and mobility filtered MS/MS data to features. In post mobility assignment workflows, the MS and MS/MS data that will be assigned to IMS parents are based on combined spectra for each IMS frame.

A few additional averaging parameters (assigned to the `avgFeatParams` and `avgMSParams` arguments) are available in IMS workflows. These are discussed in the reference manual (`?getDefAvgPListParams`).

#### Compound annotation

Candidates from compound annotations can be matched with IMS data for features, similarly as was discussed for [candidates from suspect screening](#IMSSuspScr). The `assignMobilities()` method function works similarly to assign IMS data to candidates and perform mobility <--> CCS conversions. The `filter()` method function can subsequently be used to eliminate candidates that match poorly with features ([discussed later](#IMSFiltering)).

The `assignMobilities()` function has similar arguments as the method for suspect screening:

Function argument | Description
----------------- | ---------------------------------------------------------------
`fGroups`         | The feature groups for which the `compounds` were generated.
`from`            | Specifies from where IMS data is added. See [the suspects section](#assignMobSusps) for more details.
`adduct`          | Should match the value of the `adduct` argument that was passed to `generateCompounds()`. Set to `NULL` if [adduct annotations are available for features](#incorpAdductIso) or in [sets workflows](#setsWorkflow).
`CCSParams`       | Parameters for the mobility <--> CCS conversions. See [the previous discussion](#mobCCSConv).
`overwrite`       | Set to `TRUE` to overwrite any existing IMS data in the candidate list.
`IMS`             | For which type of features IMS data should be added to the candidates: `FALSE` (only IMS parents), `TRUE` (only mobility features, default), `"both"` (both IMS parents and mobility features) or `"maybe"` (IMS parents if available, otherwise mobility features).

> **_NOTE_** If [MetFrag] with the [PubChemLite database with CCS][PCLiteCCS-dl] is used for compound annotation, then the mobility data is copied from the database and there is no need to set the `from` argument.

Some examples:

```{r exCompIMS, eval=FALSE}
# generate compound candidates
compounds <- generateCompounds(fGroups, "metfrag", adduct = "[M+H]+", database = "comptox")
# perform CCS prediction with C3SDB and convert the values to mobilities
compounds <- assignMobilities(compounds, fGroups, from = "c3sdb", adduct = "[M+H]+",
                              CCSParams = getCCSParams("bruker"))

# generate compound candidates
# NOTE: if PubChemLite with CCS data is installed, then the mobility data is automatically added
compounds <- generateCompounds(fGroups, "metfrag", adduct = "[M+H]+", database = "pubchemlite")
# overwrite CCS data from a custom library (candidates not in the library will be untouched)
IMSLib <- data.frame(
    name = c("Caffeine", "Acetaminophen"), # name column is not mandatory
    InChIKey = c("RYYVLZVUVIJVGH-UHFFFAOYSA-N", "RZVAJINKPMORJF-UHFFFAOYSA-N"),
    CCS = c(150, 160)
))
compounds <- assignMobilities(compounds, fGroups, from = IMSLib, adduct = "[M+H]+",
                              overwrite = TRUE)

```

For more details see the reference manual (`?assignMobilities_comp`).

#### Copying annotation data to mobility features with similar MS/MS data

The number of features in post mobility assignment workflows can be very large, considering that both mobility features and their IMS parents are present. Since formula and compound annotation is largely influenced by MS/MS data, it is possible to skip annotation for mobility features with highly similar MS/MS data as their IMS parent, and copy the annotations from the IMS parent result instead. The `minMobSpecSim` argument to `generateFormulas()` and `generateCompounds()` sets the minimum spectral similarity threshold for when MS/MS data is considered similar.

```{r minMobSpecSim, eval=FALSE}
# generate formulas: copy IMS parent results when the spectral similarity is at least 0.9
formulas <- generateFormulas(fGroups, "genform", adduct = "[M+H]+", minMobSpecSim = 0.9)
```

### Sets workflows {#IMSSetsWorkflow}

There is basic functionality to combine IMS workflows and [sets workflows](#setsWorfklow). However, an important limitation currently is that there is no way to group mobility features across the different sets. This is because mobility values among polarities (e.g. `[M+H]+` and `[M-H]-`) typically differ slightly and there is not a straightforward way to normalize for this. However, in post mobility assignment workflows grouping of IMS parents across sets still occurs (similar to non-IMS workflows). Hence, the links between mobility features and IMS parents can still give some indication which mobility features across sets are related. Thus, combined IMS and sets workflows are therefore mainly useful to e.g. process positive and negative sample analyses in one workflow, but lack other advantages of non-IMS sets workflows, such as easily relating features among sets and improving feature annotation with combined positive/negative MS/MS data.

Like non-IMS workflows, the `makeSet()` function is used to initialize the sets workflow. However, the method that [combines feature groups objects](#makeSetFG) is only supported for direct mobility assignment workflows.

## Processing data

The data processing functionality of `patRoon` that was [discussed before](#processing) equally applies to IMS workflows. In addition, some extra functionality exists to inspect and filter the data. These are discussed in the next subsections.

### Inspecting and plotting data

The `plotMobilograms()` method function is used to plot extracted ion mobilograms (EIMs), and works very similar as the `plotChroms()` function [introduced before](#vis_feat_ann). The function arguments are mostly equal, and the `EIMParams` argument is similarly used to configure advanced parameters (see `?getDefEIMParams` for details).

Most other plotting functions have an `IMS` argument that controls the inclusion of mobility features and IMS parents in the plots. This argument is similar as discussed before for e.g. componentization and feature annotation and supports the following values:

- `IMS=FALSE`: Do not plot any mobility features (only supported in post mobility assignment workflows).
- `IMS=TRUE`: Only plot mobility features and ignore any IMS parents.
- `IMS="both"`: Plot both mobility features and IMS parents.
- `IMS="maybe"`: Plot IMS parents if present, and mobility features otherwise. This is the default value.

The default is `"maybe"` since most plotting functions primarily use LC-MS data and therefore produce similar plots for mobility features and their IMS parents.

The `spectrumSimilarityMobility()` method function calculates the spectrum similarity between MS (or MS/MS) data of a mobility feature and its IMS parent. This function is internally used by feature annotation if the `minMobSpecSim` argument is set, and uses the `spectrumSimilarity()` function [introduced earlier](#specSim).

The [reporting functionality](#report) of `patRoon` contains various functionality that facilitates processing of IMS data.

Some examples are shown below:

```{r exInspPlotIMS, eval=FALSE}
# plot mobilogram for first feature
plotMobilograms(fGroups[, 1])
# plot mobilogram for a mobility feature: this highlights the mobility (range) assigned to the feature
plotMobilograms(fGroups[, 2], showPeakArea = TRUE, showFGroupRect = TRUE)

plot(fGroups, IMS = TRUE) # make a scatter plot with only mobility features

# returns a table with spectral similarities between mobility features and their IMS parents
spectrumSimilarityMobility(mslists, fGroups)
```

### Subsetting and filtering data {#IMSFiltering}

The following filters are specifically for IMS workflows available:

Filter           | Classes         | Remarks
-----------------|-----------------|---------------------------------------------------------------------------
`IMS`            | `featureGroups` | Only keep IMS parents (`IMS=FALSE`), mobility features (`IMS=TRUE`), both (`IMS="both"`) or IMS parents if available and mobility features otherwise (`IMS="maybe"`). The `IMS` argument is also available for the `[` operator.
`withIMSParent`  | `featureGroups` | Only keep mobility features that have an IMS parent.
`applyIMS`       | `featureGroups` | Only apply other filters to a subset of features. Should be set like the `IMS` argument.
`IMSRangeParams` | `features`, `featureGroups`, `compounds` | Only keep features/annotations within the specified mobility range. The range is configured with the `getIMSRangeParams()` function.
`IMSMatchParams` | `compounds`     | Only keep candidates that match reference IMS data. See [its description in suspect screening workflows](#screenIMS) for more details.

Some examples are shown below:

```{r exFiltIMS, eval=FALSE}
# keep only mobility features
# NOTE: this effectively results in data that is equal to a direct IMS workflow
fGroupsMob <- filter(fGroups, IMS = TRUE)
fGroupsMob <- fGroups[IMS = TRUE] # same as above

# only keep IMS parents (post mobility assignment workflows only)
# NOTE: this effectively results in data that is equal to before `assignMobilities()` was called
fGroupsIMSPar <- filter(fGroups, IMS = FALSE)

# perform various filtering steps and ensure that only mobility features with an IMS parent are kept
fGroupsF <- filter(fGroups, absMinIntensity = 1E5, relMinReplicateAbundance = 1,
                   withIMSParent = TRUE)

# perform various filtering steps, but not on mobility features
fGroupsF <- filter(fGroups, absMinIntensity = 1E5, relMinReplicateAbundance = 1,
                   applyIMS = FALSE)

# only keep compound candidates within a defined CCS range
compoundsF <- filter(compounds, IMSRangeParams = getIMSRangeParams("CCS", 150, 200))

# only keep compound candidates with matching CCS (6% tolerance)
compoundsF <- filter(compounds, IMSMatchParams = getIMSMatchParams("CCS", window = 0.06, relative = TRUE))
```

## Example workflow {#exIMSWorkflow}

The example below shows a complete IMS workflow which uses post mobility assignment for features, and includes matching of suspect and compound annotation candidates by CCS.

> **_NOTE_** The [newProject tool](#newProject) tool supports the creation of IMS workflows, and makes it easy to to create and explore different types of IMS workflows.

```{r exIMSWorkflow, eval=FALSE}
# anaInfo should be a data.frame with the analysis information

# convert raw data to ims and to centroid data
convertMSFiles(anaInfo, typeFrom = "raw", formatFrom = "bruker_ims", typeTo = "ims", formatTo = "mzML",
               algorithm = "pwiz")
convertMSFiles(anaInfo, typeFrom = "ims", formatFrom = "mzML", typeTo = "centroid", formatTo = "mzML",
               algorithm = "im_collapse")

# perform feature detection and grouping
fList <- findFeatures(anaInfo, "openms")
fGroups <- groupFeatures(fList, "openms")

# perform basic filtering
fGroups <- filter(fGroups, absMinIntensity = 1E4, relMinReplicateAbundance = 1)

# assign mobilities and CCS values
CCSParams <- getCCSParams("mason-schamp_1/k")
fGroups <- assignMobilities(fGroups, mobPeaksParams = getDefPeakParams("bruker_ims", "piek"),
                            chromPeaksParams = getDefPeakParams("chrom", "piek"),
                            CCSParams = CCSParams)

# suspect screening
suspList <- read.csv("suspects.csv")
# add CCS data from PubChemLite and convert them to mobilities
suspList <- assignMobilities(suspList, from = "pubchemlite", adducts = "[M+H]+",
                             CCSParams = CCSParams)
# screen suspects and only keep fair matches (10% CCS tolerance)
IMSMatchParams <- getIMSMatchParams("CCS", window = 0.1, relative = TRUE)
fGroups <- screenSuspects(fGroups, suspects = suspList, adduct = "[M+H]+",
                          IMSMatchParams = IMSMatchParams, onlyHits = TRUE)

# perform feature annotation
mslists <- generateMSPeakLists(fGroups)
formulas <- generateFormulas(fGroups, mslists, "genform", adduct = "[M+H]+")
# skip compound annotation for mobility features with similar MS/MS data as their IMS parent
compounds <- generateCompounds(fGroups, mslists, "metfrag", adduct = "[M+H]+", database = "pubchemlite",
                               minMobSpecSim = 0.9)
# NOTE: assume that PubChemLite with CCS data is installed, so only mobility conversions needs to be applied
compounds <- assignMobilities(compounds, fGroups, adduct = "[M+H]+", CCSParams = CCSParams)
# filter out deviating candidates
compounds <- filter(compounds, IMSMatchParams = IMSMatchParams)

report(fGroups, mslists, formulas, compounds)
```
